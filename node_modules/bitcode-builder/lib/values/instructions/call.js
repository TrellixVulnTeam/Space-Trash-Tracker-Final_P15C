"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const base_1 = require("./base");
function getCalleeType(callee) {
    const ty = callee.ty;
    // Calling function or declaration
    if (ty.isSignature()) {
        return ty.toSignature();
    }
    // A pointer to function or declaration (indirect call)
    return ty.toPointer().to.toSignature();
}
// TODO(indutny): vararg, optimizations, ret attributes
class Call extends base_1.Instruction {
    constructor(callee, args, callType = 'normal', cconv = 'ccc') {
        super(getCalleeType(callee).returnType, 'call', [callee].concat(args));
        this.callee = callee;
        this.args = args;
        this.callType = callType;
        this.cconv = cconv;
        // TODO(indutny): de-duplicate it
        this.calleeSignature = getCalleeType(callee);
        if (!callee.isConstant()) {
            return;
        }
        const constCallee = callee;
        if (constCallee.isDeclaration()) {
            const calleeFn = constCallee;
            assert.strictEqual(this.cconv, calleeFn.cconv, 'Calling convention mismatch');
        }
        assert.strictEqual(args.length, this.calleeSignature.params.length, 'Invalid number of arguments for function signature');
        this.calleeSignature.params.forEach((param, index) => {
            assert(param.isEqual(args[index].ty), `Invalid type of call parameter #${index}`);
        });
    }
}
exports.Call = Call;
//# sourceMappingURL=call.js.map