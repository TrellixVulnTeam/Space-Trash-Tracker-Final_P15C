"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const types = require("../../types");
const base_1 = require("./base");
class Metadata extends base_1.Constant {
    constructor(value) {
        super(new types.Metadata());
        this.value = value;
        this.privSelfReference = false;
        this.privDistinct = false;
    }
    get selfReference() { return this.privSelfReference; }
    get distinct() { return this.privDistinct; }
    addSelfReference() {
        assert(Array.isArray(this.value), 'Can\'t add self-reference to non-tuple metadata');
        this.privSelfReference = true;
        return this;
    }
    markDistinct() {
        assert(Array.isArray(this.value), 'Can\'t have distinct non-tuple metadata');
        this.privDistinct = true;
        return this;
    }
    isEqual(to) {
        if (this === to) {
            return true;
        }
        if (!to.isMetadata()) {
            return false;
        }
        const toValue = to.value;
        if (typeof toValue === 'string') {
            return toValue === this.value;
        }
        if (toValue instanceof base_1.Constant) {
            return this.value instanceof base_1.Constant && toValue.isEqual(this.value);
        }
        // `toValue` is an Array
        if (!Array.isArray(this.value)) {
            return false;
        }
        if (toValue.length !== this.value.length) {
            return false;
        }
        return toValue.every((subValue, index) => {
            return subValue.isEqual(this.value[index]);
        });
    }
    toString() {
        // TODO(indutny): print more
        return '[metadata]';
    }
}
exports.Metadata = Metadata;
//# sourceMappingURL=metadata.js.map