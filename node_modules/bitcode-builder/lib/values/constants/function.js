"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const utils_1 = require("../../utils");
const values_1 = require("../../values");
const declaration_1 = require("./declaration");
// TODO(indutny): `.verify()` method
class Func extends declaration_1.Declaration {
    constructor(signature, name, paramNames) {
        super(signature, name);
        this.paramNames = paramNames;
        this.body = this.createBlock();
        this.metadata = new Map();
        this.paramMap = new Map();
        this.blockList = undefined;
        assert.strictEqual(paramNames.length, signature.params.length, 'Invalid number of parameter names, doesn\'t match signature');
        paramNames.forEach((paramName, i) => {
            if (this.paramMap.has(paramName)) {
                throw new Error(`Duplicate parameter name: "${paramName}"`);
            }
            assert(utils_1.validateName(paramName), `Invalid characters in parameter name: "${paramName}"`);
            this.paramMap.set(paramName, i);
        });
        this.args = signature.params.map((param, i) => {
            return new values_1.Argument(param, i, this.paramNames[i]);
        });
    }
    toString() {
        return `[function name=${this.name}]`;
    }
    createBlock(name) {
        return new values_1.BasicBlock(this, name);
    }
    getArgument(name) {
        assert(this.paramMap.has(name), `Unknown parameter name: "${name}"`);
        const index = this.paramMap.get(name);
        return this.args[index];
    }
    *[Symbol.iterator]() {
        if (this.blockList !== undefined) {
            yield* this.blockList;
            return;
        }
        const visited = new Set();
        const queue = [this.body];
        let canCache = true;
        const list = [];
        while (queue.length !== 0) {
            const bb = queue.pop();
            if (visited.has(bb)) {
                continue;
            }
            visited.add(bb);
            if (!bb.isTerminated()) {
                canCache = false;
            }
            list.push(bb);
            yield bb;
            // Push successors in reverse order, so that we'll pop the first on
            // next iteration
            for (let i = bb.successors.length - 1; i >= 0; i--) {
                queue.push(bb.successors[i]);
            }
        }
        if (canCache) {
            this.blockList = list;
        }
    }
}
exports.Func = Func;
//# sourceMappingURL=function.js.map