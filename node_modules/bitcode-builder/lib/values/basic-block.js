"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const utils_1 = require("../utils");
const types_1 = require("../types");
const base_1 = require("./base");
const instructions_1 = require("./instructions");
class BasicBlock extends base_1.Value {
    constructor(parent, name) {
        super(new types_1.Label());
        this.parent = parent;
        this.privPredecessors = [];
        this.privSuccessors = [];
        this.instructions = [];
        this.phis = [];
        this.privTerminator = undefined;
        this.privName = undefined;
        if (name !== undefined) {
            this.name = name;
        }
    }
    toString() {
        if (this.name === undefined) {
            return '[anonymous block]';
        }
        else {
            return `[block ${this.name}]`;
        }
    }
    get name() {
        return this.privName;
    }
    set name(value) {
        if (value !== undefined) {
            assert(utils_1.validateName(value), `Invalid characters in Block name: "${value}"`);
        }
        this.privName = value;
    }
    get terminator() {
        return this.privTerminator;
    }
    isTerminated() { return this.privTerminator !== undefined; }
    get predecessors() {
        return this.privPredecessors;
    }
    get successors() {
        return this.privSuccessors;
    }
    // Special instructions
    phi(edgeOrTy) {
        assert.strictEqual(this.terminator, undefined, 'Can\'t push into terminated block');
        const phi = new instructions_1.Phi(edgeOrTy);
        this.phis.push(phi);
        return phi;
    }
    // Regular instructions
    binop(binopType, left, right) {
        return this.push(new instructions_1.Binop(binopType, left, right));
    }
    cast(castType, value, targetType) {
        return this.push(new instructions_1.Cast(castType, value, targetType));
    }
    icmp(predicate, left, right) {
        return this.push(new instructions_1.ICmp(predicate, left, right));
    }
    load(ptr, alignment, isVolatile = false) {
        return this.push(new instructions_1.Load(ptr, alignment, isVolatile));
    }
    store(value, ptr, alignment, isVolatile = false) {
        return this.push(new instructions_1.Store(value, ptr, alignment, isVolatile));
    }
    getelementptr(ptr, ptrIndex, index, inbounds = false) {
        return this.push(new instructions_1.GetElementPtr(ptr, ptrIndex, index, inbounds));
    }
    extractvalue(aggr, index) {
        return this.push(new instructions_1.ExtractValue(aggr, index));
    }
    insertvalue(aggr, elem, index) {
        return this.push(new instructions_1.InsertValue(aggr, elem, index));
    }
    call(callee, args, callType = 'normal', cconv) {
        // Pick cconv from declaration
        if (!cconv && callee.isConstant()) {
            const decl = callee.toConstant().toDeclaration();
            cconv = decl.cconv;
        }
        return this.push(new instructions_1.Call(callee, args, callType, cconv));
    }
    // Terminators
    ret(operand) {
        const returnType = this.parent.ty.toSignature().returnType;
        if (operand === undefined) {
            assert(returnType.isVoid(), 'Void return from non-Void function');
        }
        else {
            assert(returnType.isEqual(operand.ty), 'Return type mismatch');
        }
        return this.terminate(new instructions_1.Ret(operand));
    }
    jmp(target) {
        this.addSuccessor(target);
        return this.terminate(new instructions_1.Jump(target));
    }
    branch(condition, onTrue, onFalse) {
        this.addSuccessor(onTrue);
        this.addSuccessor(onFalse);
        return this.terminate(new instructions_1.Branch(condition, onTrue, onFalse));
    }
    switch(condition, otherwise, cases) {
        this.addSuccessor(otherwise);
        cases.forEach((c) => this.addSuccessor(c.block));
        return this.terminate(new instructions_1.Switch(condition, otherwise, cases));
    }
    unreachable() {
        return this.terminate(new instructions_1.Unreachable());
    }
    *[Symbol.iterator]() {
        yield* this.phis;
        yield* this.instructions;
    }
    // Helpers
    push(instr) {
        assert.strictEqual(this.terminator, undefined, 'Can\'t push into terminated block');
        this.instructions.push(instr);
        return instr;
    }
    terminate(instr) {
        assert.strictEqual(this.terminator, undefined, 'Block already terminated');
        this.instructions.push(instr);
        this.privTerminator = instr;
        return instr;
    }
    addSuccessor(block) {
        this.privSuccessors.push(block);
        block.privPredecessors.push(this);
    }
}
exports.BasicBlock = BasicBlock;
//# sourceMappingURL=basic-block.js.map