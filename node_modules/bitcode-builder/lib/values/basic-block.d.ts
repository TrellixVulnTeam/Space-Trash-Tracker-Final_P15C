import { CallingConv } from '../calling-conv';
import { Type } from '../types';
import { Value } from './base';
import { Func } from './constants';
import { Binop, BinopType, Branch, Call, CallType, Cast, CastType, ExtractValue, GetElementPtr, ICmp, ICmpPredicate, InsertValue, Instruction, IPhiEdge, ISwitchCase, Jump, Load, Phi, Ret, Store, Switch, Unreachable } from './instructions';
export declare class BasicBlock extends Value {
    readonly parent: Func;
    protected readonly privPredecessors: BasicBlock[];
    protected readonly privSuccessors: BasicBlock[];
    private readonly instructions;
    private readonly phis;
    private privTerminator;
    private privName;
    constructor(parent: Func, name?: string);
    toString(): string;
    name: string | undefined;
    readonly terminator: Instruction | undefined;
    isTerminated(): boolean;
    readonly predecessors: ReadonlyArray<BasicBlock>;
    readonly successors: ReadonlyArray<BasicBlock>;
    phi(edgeOrTy: Type | IPhiEdge): Phi;
    binop(binopType: BinopType, left: Value, right: Value): Binop;
    cast(castType: CastType, value: Value, targetType: Type): Cast;
    icmp(predicate: ICmpPredicate, left: Value, right: Value): ICmp;
    load(ptr: Value, alignment?: number, isVolatile?: boolean): Load;
    store(value: Value, ptr: Value, alignment?: number, isVolatile?: boolean): Store;
    getelementptr(ptr: Value, ptrIndex: Value, index?: Value, inbounds?: boolean): GetElementPtr;
    extractvalue(aggr: Value, index: number): ExtractValue;
    insertvalue(aggr: Value, elem: Value, index: number): InsertValue;
    call(callee: Value, args: ReadonlyArray<Value>, callType?: CallType, cconv?: CallingConv): Call;
    ret(operand?: Value): Ret;
    jmp(target: BasicBlock): Jump;
    branch(condition: Value, onTrue: BasicBlock, onFalse: BasicBlock): Branch;
    switch(condition: Value, otherwise: BasicBlock, cases: ISwitchCase[]): Switch;
    unreachable(): Unreachable;
    [Symbol.iterator](): Iterator<Instruction>;
    private push<T>(instr);
    private terminate<T>(instr);
    private addSuccessor(block);
}
