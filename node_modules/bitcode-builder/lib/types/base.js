"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const types = require("../types");
const values = require("../values");
class Type {
    constructor(privTypeString) {
        this.privTypeString = privTypeString;
    }
    get typeString() {
        return this.privTypeString;
    }
    ptr() {
        return new types.Pointer(this);
    }
    val(_) {
        throw new Error('Not supported');
    }
    undef() {
        return new values.constants.Undef(this);
    }
    isVoid() { return this instanceof types.Void; }
    isInt() { return this instanceof types.Int; }
    isLabel() { return this instanceof types.Label; }
    isMetadata() { return this instanceof types.Metadata; }
    isPointer() { return this instanceof types.Pointer; }
    isSignature() { return this instanceof types.Signature; }
    isStruct() { return this instanceof types.Struct; }
    isArray() { return this instanceof types.Array; }
    toVoid() {
        assert(this.isVoid(), 'Type is not a Void instance');
        return this;
    }
    toInt() {
        assert(this.isInt(), 'Type is not an Int instance');
        return this;
    }
    toLabel() {
        assert(this.isLabel(), 'Type is not a Label instance');
        return this;
    }
    toMetadata() {
        assert(this.isMetadata(), 'Type is not a Metadata instance');
        return this;
    }
    toPointer() {
        assert(this.isPointer(), 'Type is not a Pointer instance');
        return this;
    }
    toSignature() {
        assert(this.isSignature(), 'Type is not a Signature instance');
        return this;
    }
    toStruct() {
        assert(this.isStruct(), 'Type is not a Struct instance');
        return this;
    }
    toArray() {
        assert(this.isArray(), 'Type is not an Array instance');
        return this;
    }
}
exports.Type = Type;
//# sourceMappingURL=base.js.map