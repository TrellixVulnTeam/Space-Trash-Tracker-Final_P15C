"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const utils_1 = require("../../utils");
const values = require("../../values");
const base_1 = require("../base");
const field_1 = require("./field");
exports.Field = field_1.Field;
class Struct extends base_1.Type {
    constructor(name) {
        super('struct');
        this.name = name;
        this.privFields = [];
        this.fieldMap = new Map();
        this.finalized = false;
        if (name !== undefined) {
            assert(utils_1.validateName(name), `Invalid characters in Struct name: "${name}"`);
        }
    }
    get typeString() {
        // Named struct
        if (this.name !== undefined) {
            return `%${this.name}`;
        }
        return this.anonymousTypeString;
    }
    get anonymousTypeString() {
        this.checkFinalized();
        // Anonymous struct
        return '{ ' + this.fields.map((f) => f.ty.typeString).join(', ') + ' }';
    }
    get fields() { return this.privFields; }
    isEqual(to) {
        this.checkFinalized();
        if (this === to) {
            return true;
        }
        if (!to.isStruct()) {
            return false;
        }
        const toStruct = to;
        toStruct.checkFinalized();
        return toStruct.fields.length === this.fields.length &&
            toStruct.fields.every((field, i) => field.ty.isEqual(this.fields[i].ty));
    }
    val(map) {
        this.checkFinalized();
        const keys = Object.keys(map);
        assert.strictEqual(keys.length, this.fields.length, 'Invalid key count in `map` argument of `.val()`');
        const fields = new Array(this.fields.length);
        keys.forEach((key) => {
            const field = this.lookupField(key);
            assert(field.ty.isEqual(map[key].ty), `Type mismatch for "${key}" field value`);
            fields[field.index] = map[key];
        });
        return new values.constants.Struct(this, fields);
    }
    finalize() {
        assert(!this.finalized, 'Double finalization');
        this.finalized = true;
    }
    addField(ty, name) {
        assert(utils_1.validateName(name), `Invalid characters in struct field name: "${name}"`);
        assert(!this.finalized, 'Can\'t add fields after `.finalize()` call');
        if (this.fieldMap.has(name)) {
            const existing = this.fieldMap.get(name);
            assert(existing.ty.isEqual(ty), 'Conflicting field types for: ' + name);
            return existing;
        }
        assert(!ty.isVoid(), 'Fields can\'t have void type');
        assert(!ty.isSignature(), 'Fields can\'t have signature types, please use `sig.ptr()`');
        const add = new field_1.Field(ty, name, this.privFields.length);
        this.privFields.push(add);
        this.fieldMap.set(name, add);
        return add;
    }
    hasField(name) {
        return this.fieldMap.has(name);
    }
    lookupField(name) {
        assert(this.hasField(name), `Field "${name}" is unknown`);
        return this.fieldMap.get(name);
    }
    getField(index) {
        assert(0 <= index && index < this.fields.length, 'Invalid field index');
        return this.fields[index];
    }
    checkFinalized() {
        assert(this.finalized, 'Please call `.finalize()` on the Struct instance first');
    }
}
exports.Struct = Struct;
//# sourceMappingURL=index.js.map