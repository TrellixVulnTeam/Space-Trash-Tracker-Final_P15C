"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const byte_writer_1 = require("./byte-writer");
const BYTE_BITS = 8;
const WORD_BITS = 16;
const DWORD_BITS = 32;
class BitWriter {
    constructor() {
        this.writer = new byte_writer_1.ByteWriter();
        // Current double word
        this.dword = 0;
        // Bits left in current word
        this.dwordLeft = DWORD_BITS;
        // Bit offset in current word
        this.dwordOff = 0;
    }
    get offset() { return this.writer.offset; }
    get bitOffset() {
        return this.offset * BYTE_BITS + this.dwordOff;
    }
    writeBits(value, width) {
        if (width === 0) {
            return this;
        }
        assert(0 < width && width <= DWORD_BITS, 'Invalid number of bits');
        const fits = Math.min(this.dwordLeft, width);
        let mask;
        if (fits === 32) {
            mask = 0xffffffff;
        }
        else {
            mask = ((1 << fits) >>> 0) - 1;
        }
        // Split on boundary
        if (fits < width) {
            this.writeBits(value & mask, fits);
            this.writeBits(value >>> fits, width - fits);
            return this;
        }
        this.dword |= (value & mask) << this.dwordOff;
        this.dwordOff += width;
        this.dwordLeft -= width;
        // Flush word when it is full
        if (this.dwordLeft === 0) {
            this.writer.writeDWord(this.dword);
            this.dword = 0;
            this.dwordOff = 0;
            this.dwordLeft = DWORD_BITS;
        }
        return this;
    }
    writeByte(value) {
        return this.writeBits(value, BYTE_BITS);
    }
    writeWord(value) {
        return this.writeBits(value, WORD_BITS);
    }
    writeDWord(value) {
        return this.writeBits(value, DWORD_BITS);
    }
    pad(width) {
        return this.writeBits(0, width);
    }
    align(width) {
        return this.pad(this.dwordLeft % width);
    }
    reserve(width) {
        assert.strictEqual(width % BYTE_BITS, 0, 'Only bytes can be reserved');
        assert.strictEqual(this.dwordOff % BYTE_BITS, 0, 'Must be aligned before reservation');
        this.flush();
        return this.writer.reserve(width / BYTE_BITS);
    }
    end() {
        this.flush();
        return this.writer.end();
    }
    flush() {
        // Flush remaining data
        if (this.dwordOff === 0) {
            return;
        }
        this.align(BYTE_BITS);
        if (this.dwordOff === BYTE_BITS + WORD_BITS) {
            this.writer.writeByte(this.dword & 0xff);
            this.writer.writeWord(this.dword >>> 8);
        }
        else if (this.dwordOff === WORD_BITS) {
            this.writer.writeWord(this.dword);
        }
        else if (this.dwordOff === BYTE_BITS) {
            this.writer.writeByte(this.dword);
        }
        else {
            assert.strictEqual(this.dwordOff, 0);
        }
        this.dwordLeft = DWORD_BITS;
        this.dwordOff = 0;
    }
}
exports.BitWriter = BitWriter;
//# sourceMappingURL=bit-writer.js.map