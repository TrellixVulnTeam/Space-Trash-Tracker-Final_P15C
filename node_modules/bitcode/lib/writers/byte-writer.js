"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const buffer_1 = require("buffer");
const CHUNK_SIZE = 16 * 1024;
class ByteWriter {
    constructor() {
        // Total size of all pushed chunks in bytes
        this.size = 0;
        // Current chunk
        this.current = buffer_1.Buffer.alloc(CHUNK_SIZE);
        // Offset in current chunk
        this.chunkOffset = 0;
        // Bytes left in current chunk
        this.chunkLeft = CHUNK_SIZE;
        // Array of completed chunks
        this.chunks = [];
    }
    get offset() { return this.size + this.chunkOffset; }
    writeByte(value) {
        const chunk = this.ensureChunk();
        // We have at least one byte here
        chunk.writeUInt8(value >>> 0, this.chunkOffset);
        this.chunkOffset++;
        this.chunkLeft--;
        return this;
    }
    writeWord(value) {
        const chunk = this.ensureChunk();
        if (this.chunkLeft >= 2) {
            chunk.writeUInt16LE((value & 0xffff) >>> 0, this.chunkOffset);
            this.chunkLeft -= 2;
            this.chunkOffset += 2;
            return this;
        }
        // Just one byte available
        this.writeByte(value & 0xff);
        this.writeByte((value >>> 8) & 0xff);
        return this;
    }
    writeDWord(value) {
        const chunk = this.ensureChunk();
        if (this.chunkLeft >= 4) {
            chunk.writeUInt32LE(value >>> 0, this.chunkOffset);
            this.chunkLeft -= 4;
            this.chunkOffset += 4;
            return this;
        }
        // Less than four bytes available
        this.writeWord(value & 0xffff);
        this.writeWord((value >>> 16) & 0xffff);
        return this;
    }
    reserve(bytes) {
        this.flush();
        const chunk = this.ensureChunk();
        assert(this.chunkLeft >= bytes, '`reserve()` OOB');
        const endOff = this.chunkOffset + bytes;
        const res = this.current.slice(this.chunkOffset, endOff);
        this.chunkLeft -= bytes;
        this.chunkOffset = endOff;
        return res;
    }
    end() {
        this.flush();
        return buffer_1.Buffer.concat(this.chunks, this.size);
    }
    // Private
    push(chunk) {
        this.chunks.push(chunk);
        this.size += chunk.length;
    }
    ensureChunk() {
        if (this.chunkLeft !== 0) {
            return this.current;
        }
        // No push after `flush`
        if (this.chunkOffset !== 0) {
            this.push(this.current);
        }
        this.chunkOffset = 0;
        this.chunkLeft = CHUNK_SIZE;
        this.current = buffer_1.Buffer.alloc(CHUNK_SIZE);
        return this.current;
    }
    flush() {
        if (this.chunkOffset === 0) {
            return;
        }
        this.push(this.current.slice(0, this.chunkOffset));
        this.chunkOffset = 0;
        this.chunkLeft = 0;
    }
}
exports.ByteWriter = ByteWriter;
//# sourceMappingURL=byte-writer.js.map