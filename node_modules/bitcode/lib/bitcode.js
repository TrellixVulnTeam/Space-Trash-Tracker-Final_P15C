"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const builder = require("bitcode-builder");
exports.builder = builder;
const buffer_1 = require("buffer");
const bitstream_1 = require("./bitstream");
const blocks_1 = require("./blocks");
const constants_1 = require("./constants");
const encoding_1 = require("./encoding");
const enumerator_1 = require("./enumerator");
var Builder = builder.Builder;
exports.Builder = Builder;
var passes = builder.passes;
var values = builder.values;
var constants = values.constants;
const MAGIC = 0xdec04342;
const VERSION = 2;
const MODULE_ABBR_ID_WIDTH = 3;
class Module {
    constructor(sourceName) {
        this.sourceName = sourceName;
        this.usedNames = new Set();
        this.fns = [];
        this.decls = new Map();
        this.globals = new Map();
        this.enumerator = new enumerator_1.Enumerator();
        this.typeBlock = new blocks_1.TypeBlock();
        this.paramAttrBlock = new blocks_1.ParamAttrBlock();
        this.strtab = new blocks_1.StrtabBlock();
    }
    addFunction(fn) {
        this.useGlobalName(fn.name);
        this.fns.push(fn);
    }
    addDeclaration(decl) {
        if (this.decls.has(decl.name)) {
            const existing = this.decls.get(decl.name);
            assert(decl.isEqual(existing), 'Declaration already exists with a different spec');
            // TODO(indutny): verify attributes
            return;
        }
        this.useGlobalName(decl.name);
        this.decls.set(decl.name, decl);
    }
    addGlobal(g) {
        if (this.globals.has(g.name)) {
            const existing = this.globals.get(g.name);
            // TODO(indutny): linkage, and so on
            assert(g.ty.isEqual(existing.ty), 'Global already exists with a different type: ' +
                `"${existing.ty.typeString}"`);
            return;
        }
        this.useGlobalName(g.name);
        this.globals.set(g.name, g);
    }
    build() {
        this.verify();
        const writer = new bitstream_1.BitStream({
            magic: MAGIC,
        });
        writer.enterBlock(constants_1.BLOCK_ID.MODULE, MODULE_ABBR_ID_WIDTH);
        writer.writeUnabbrRecord(constants_1.MODULE_CODE.VERSION, [VERSION]);
        this.defineBlockInfo(writer);
        if (this.sourceName !== undefined) {
            const arr = Array.from(buffer_1.Buffer.from(this.sourceName));
            // TODO(indutny): use char6, or fixed7 if compatible
            writer.defineAbbr(new bitstream_1.Abbr('filename', [
                bitstream_1.Abbr.literal(constants_1.MODULE_CODE.SOURCE_FILENAME),
                bitstream_1.Abbr.array(bitstream_1.Abbr.fixed(constants_1.FIXED.CHAR)),
            ]));
            writer.writeRecord('filename', [arr]);
        }
        const decls = Array.from(this.decls.values());
        const globals = Array.from(this.globals.values());
        // LLVM enumerates values in specific order, attach id to each before
        // emitting binary data
        this.enumerator.enumerate({
            decls,
            fns: this.fns,
            globals,
        });
        // Add types from used values
        for (const value of this.enumerator) {
            this.typeBlock.add(value.ty);
        }
        this.typeBlock.build(writer);
        // Add attributes from globals
        for (const global of globals) {
            this.paramAttrBlock.addGlobal(global);
        }
        // Add attributes from declarations
        for (const decl of decls) {
            this.paramAttrBlock.addDecl(decl);
        }
        // Add attributes from functions
        for (const fn of this.fns) {
            this.paramAttrBlock.addDecl(fn);
        }
        const metadataKindBlock = new blocks_1.MetadataKindBlock(this.enumerator.getMetadataKinds());
        metadataKindBlock.build(writer);
        this.paramAttrBlock.build(writer);
        this.buildGlobals(writer, globals);
        const globalConstants = new blocks_1.ConstantBlock(this.enumerator, this.typeBlock, this.enumerator.getGlobalConstants());
        globalConstants.build(writer);
        this.buildDeclarations(writer);
        this.buildFunctionBodies(writer);
        writer.endBlock(constants_1.BLOCK_ID.MODULE);
        // Build STRTAB last, when we've added all strings to it
        this.strtab.build(writer);
        return writer.end();
    }
    // Convenience methods
    createBuilder() {
        return new Builder();
    }
    add(value) {
        // NOTE: test `Func` first since it is a subclass of `Declaration`
        if (value instanceof constants.Func) {
            this.addFunction(value);
        }
        else if (value instanceof constants.Declaration) {
            this.addDeclaration(value);
        }
        else if (value instanceof values.Global) {
            this.addGlobal(value);
        }
        else {
            throw new Error('Unexpected value type: ' + value.constructor.name);
        }
        return this;
    }
    // Private API
    verify() {
        const pass = new passes.Verify({
            declarations: Array.from(this.decls.values()),
            functions: this.fns,
            globals: Array.from(this.globals.values()),
        });
        pass.run();
    }
    defineBlockInfo(writer) {
        const info = new Map();
        blocks_1.ConstantBlock.buildInfo(info);
        blocks_1.FunctionBlock.buildInfo(info);
        blocks_1.MetadataBlock.buildInfo(info);
        writer.writeBlockInfo(info);
    }
    // TODO(indutny): support section, alignment, etc
    // TODO(indutny): metadata
    buildGlobals(writer, globals) {
        writer.defineAbbr(new bitstream_1.Abbr('global', [
            bitstream_1.Abbr.literal(constants_1.MODULE_CODE.GLOBALVAR),
            bitstream_1.Abbr.vbr(constants_1.VBR.STRTAB_OFFSET),
            bitstream_1.Abbr.vbr(constants_1.VBR.STRTAB_LENGTH),
            bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
            bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
            bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
            bitstream_1.Abbr.fixed(constants_1.FIXED.LINKAGE),
            bitstream_1.Abbr.vbr(constants_1.VBR.ALIGNMENT),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.fixed(constants_1.FIXED.VISIBILITY),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(constants_1.UNNAMED_ADDR.NO),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.vbr(constants_1.VBR.ATTR_INDEX),
            bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
        ]));
        for (const g of globals) {
            const name = this.strtab.add(g.name);
            this.enumerator.checkValueOrder(g);
            const attributes = this.paramAttrBlock.get(g);
            writer.writeRecord('global', [
                name.offset,
                name.length,
                this.typeBlock.get(g.ty),
                g.hasConstantValue() ? 1 : 0,
                g.init === undefined ? 0 : 1 + this.enumerator.get(g.init),
                encoding_1.encodeLinkage(g.linkage),
                0,
                constants_1.VISIBILITY.DEFAULT,
                attributes === undefined ? 0 : 1 + attributes,
                // dso_local
                (g.linkage === 'private' || g.linkage === 'internal') ? 1 : 0,
            ]);
        }
    }
    buildDeclarations(writer) {
        // TODO(indutny): support unnamed_addr, others?
        writer.defineAbbr(new bitstream_1.Abbr('decl', [
            bitstream_1.Abbr.literal(constants_1.MODULE_CODE.FUNCTION),
            bitstream_1.Abbr.vbr(constants_1.VBR.STRTAB_OFFSET),
            bitstream_1.Abbr.vbr(constants_1.VBR.STRTAB_LENGTH),
            bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
            bitstream_1.Abbr.vbr(constants_1.VBR.CCONV),
            bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
            bitstream_1.Abbr.fixed(constants_1.FIXED.LINKAGE),
            bitstream_1.Abbr.vbr(constants_1.VBR.ATTR_INDEX),
            bitstream_1.Abbr.vbr(constants_1.VBR.ALIGNMENT),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.fixed(constants_1.FIXED.VISIBILITY),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(constants_1.UNNAMED_ADDR.NO),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.literal(0),
            bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
        ]));
        const allDecls = this.fns
            .concat(Array.from(this.decls.values()));
        for (const decl of allDecls) {
            const name = this.strtab.add(decl.name);
            this.enumerator.checkValueOrder(decl);
            const attributes = this.paramAttrBlock.get(decl);
            writer.writeRecord('decl', [
                name.offset,
                name.length,
                this.typeBlock.get(decl.ty),
                encoding_1.encodeCConv(decl.cconv),
                decl.isFunction() ? 0 : 1,
                encoding_1.encodeLinkage(decl.linkage),
                attributes === undefined ? 0 : 1 + attributes,
                0,
                constants_1.VISIBILITY.DEFAULT,
                // dso_local
                (decl.linkage === 'private' || decl.linkage === 'internal') ? 1 : 0,
            ]);
        }
    }
    buildFunctionBodies(writer) {
        for (const fn of this.fns) {
            const block = new blocks_1.FunctionBlock(this.enumerator, this.typeBlock, fn);
            block.build(writer);
        }
    }
    useGlobalName(name) {
        if (this.usedNames.has(name)) {
            throw new Error(`Global name clash for: "${name}"`);
        }
        this.usedNames.add(name);
    }
}
exports.Module = Module;
//# sourceMappingURL=bitcode.js.map