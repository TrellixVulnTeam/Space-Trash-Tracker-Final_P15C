"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const bitcode_builder_1 = require("bitcode-builder");
var EnumerationMode;
(function (EnumerationMode) {
    EnumerationMode[EnumerationMode["ALL"] = 0] = "ALL";
    EnumerationMode[EnumerationMode["CONSTANTS_ONLY"] = 1] = "CONSTANTS_ONLY";
})(EnumerationMode || (EnumerationMode = {}));
class Enumerator {
    constructor() {
        this.globals = new Map();
        this.map = new Map();
        this.index = 0;
        this.lastGlobalIndex = 0;
        this.globalConstants = [];
        this.functionConstants = new Map();
        this.functionMetadata = new Map();
        this.metadataKinds = new Map();
        this.lastEmittedIndex = 0;
    }
    enumerate(input) {
        // 1. Enumerate globals
        for (const g of input.globals) {
            assert(!this.globals.has(g.name));
            this.globals.set(g.name, g);
            this.enumerateGlobal(g);
        }
        // 2. Their initialization values
        for (const g of input.globals) {
            if (g.init) {
                this.enumerateGlobalConst(g.init);
            }
        }
        // 3. Enumerate functions
        for (const fn of input.fns) {
            this.enumerateDeclaration(fn);
        }
        // 4. Enumerate declarations
        for (const decl of input.decls) {
            assert(!this.globals.has(decl.name));
            this.globals.set(decl.name, decl);
            this.enumerateDeclaration(decl);
        }
        this.lastGlobalIndex = this.index;
        // 5. Enumerate function bodies
        for (const fn of input.fns) {
            this.enumerateFunction(fn);
        }
    }
    get(value) {
        assert(this.map.has(value), 'Stumbled upon non-enumerated value');
        return this.map.get(value);
    }
    *[Symbol.iterator]() {
        yield* this.map.keys();
    }
    getGlobalConstants() {
        return this.globalConstants;
    }
    getFunctionConstants(fn) {
        assert(this.functionConstants.has(fn), `Unexpected function: "${fn.name}"`);
        return this.functionConstants.get(fn);
    }
    getMetadataKinds() {
        return this.metadataKinds;
    }
    getFunctionMetadata(fn) {
        assert(this.functionMetadata.has(fn), `Unexpected function: "${fn.name}"`);
        return this.functionMetadata.get(fn);
    }
    // Ensure that values are emitted in the same order they were enumerated
    checkValueOrder(value) {
        const index = this.get(value);
        assert(index >= this.lastEmittedIndex, 'Invalid order of values (internal error)');
        this.lastEmittedIndex = index;
    }
    leaveFunction() {
        assert(this.lastEmittedIndex >= this.lastGlobalIndex, 'Invalid order of values (internal error)');
        this.lastEmittedIndex = this.lastGlobalIndex;
    }
    // Private API
    enumerateValue(value, mode = EnumerationMode.ALL) {
        if (this.constList !== undefined && value.isConstant() &&
            !value.toConstant().isDeclaration()) {
            this.constList.push(value.toConstant());
        }
        if (this.map.has(value)) {
            return;
        }
        if (mode === EnumerationMode.CONSTANTS_ONLY && !value.isConstant()) {
            return;
        }
        if (value instanceof bitcode_builder_1.values.constants.Declaration ||
            value instanceof bitcode_builder_1.values.Global) {
            // There might be different instances of same declaration/global
            // redirect them all to the first one
            if (this.globals.has(value.name)) {
                const existing = this.globals.get(value.name);
                assert(value.ty.isEqual(existing.ty), 'Conflicting type for global/declaration: ' + value.name);
                this.enumerateValue(existing, mode);
                const existingId = this.map.get(existing);
                if (existingId !== undefined) {
                    this.map.set(value, existingId);
                }
                return;
            }
            throw new Error('Missing global/declaration: ' + value.name);
        }
        this.map.set(value, this.index);
        if (!value.ty.isVoid()) {
            this.index++;
        }
    }
    enumerateGlobal(global) {
        this.map.set(global, this.index++);
    }
    enumerateGlobalConst(c) {
        if (c.isArray()) {
            for (const elem of c.toArray().elems) {
                this.enumerateGlobalConst(elem);
            }
        }
        else if (c.isStruct()) {
            for (const field of c.toStruct().fields) {
                this.enumerateGlobalConst(field);
            }
        }
        // TODO(indutny): global metadata
        this.globalConstants.push(c);
        this.enumerateValue(c);
    }
    enumerateFunction(fn) {
        const constList = [];
        const metadataList = [];
        for (const arg of fn.args) {
            this.enumerateValue(arg);
        }
        this.constList = constList;
        this.metadataList = metadataList;
        // Enumerate constants and metadata first
        for (const bb of fn) {
            this.enumerateBlock(bb, EnumerationMode.CONSTANTS_ONLY);
        }
        this.constList = undefined;
        this.metadataList = undefined;
        // All instructions later
        for (const bb of fn) {
            this.enumerateBlock(bb, EnumerationMode.ALL);
        }
        this.functionConstants.set(fn, constList);
        this.functionMetadata.set(fn, metadataList);
        // Leave the function
        this.index = this.lastGlobalIndex;
    }
    enumerateDeclaration(decl) {
        this.map.set(decl, this.index++);
    }
    enumerateBlock(bb, mode) {
        for (const instr of bb) {
            // All operands, except constants should be already enumerated
            for (const operand of instr) {
                this.enumerateValue(operand, EnumerationMode.CONSTANTS_ONLY);
            }
            if (mode === EnumerationMode.CONSTANTS_ONLY) {
                instr.metadata.forEach((metadata, key) => {
                    if (!this.metadataKinds.has(key)) {
                        this.metadataKinds.set(key, this.metadataKinds.size);
                    }
                    this.enumerateMetadata(metadata);
                });
            }
            this.enumerateValue(instr, mode);
        }
    }
    enumerateMetadata(metadata) {
        if (this.metadataList !== undefined) {
            this.metadataList.push(metadata);
        }
        // Tuple
        if (Array.isArray(metadata.value)) {
            metadata.value.forEach((subMeta) => this.enumerateMetadata(subMeta));
            // String
        }
        else if (typeof metadata.value === 'string') {
            // no-op
            // Constant
        }
        else {
            this.enumerateValue(metadata.value);
        }
    }
}
exports.Enumerator = Enumerator;
//# sourceMappingURL=enumerator.js.map