"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const buffer_1 = require("buffer");
const bitstream_1 = require("../bitstream");
const constants_1 = require("../constants");
const base_1 = require("./base");
const METADATA_ABBR_ID_WIDTH = 3;
const LEN_WRITER_VBR = 6;
const DWORD_BITS = 32;
class MetadataBlock extends base_1.Block {
    constructor(enumerator, typeBlock, list) {
        super();
        this.enumerator = enumerator;
        this.typeBlock = typeBlock;
        this.map = new Map();
        this.strings = new Map();
        this.values = [];
        this.tuples = [];
        list.forEach((metadata) => this.add(metadata));
    }
    static buildInfo(info) {
        info.set(constants_1.BLOCK_ID.METADATA, [
            new bitstream_1.Abbr('strings', [
                bitstream_1.Abbr.literal(constants_1.METADATA_CODE.STRINGS),
                bitstream_1.Abbr.vbr(constants_1.VBR.METADATA_STRING_COUNT),
                bitstream_1.Abbr.vbr(constants_1.VBR.METADATA_STRING_OFF),
                bitstream_1.Abbr.blob(),
            ]),
            new bitstream_1.Abbr('tuple', [
                bitstream_1.Abbr.literal(constants_1.METADATA_CODE.NODE),
                bitstream_1.Abbr.array(bitstream_1.Abbr.vbr(constants_1.VBR.METADATA_INDEX)),
            ]),
            new bitstream_1.Abbr('distinct_tuple', [
                bitstream_1.Abbr.literal(constants_1.METADATA_CODE.DISTINCT_NODE),
                bitstream_1.Abbr.array(bitstream_1.Abbr.vbr(constants_1.VBR.METADATA_INDEX)),
            ]),
            new bitstream_1.Abbr('value', [
                bitstream_1.Abbr.literal(constants_1.METADATA_CODE.VALUE),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
            ]),
        ]);
    }
    get(metadata) {
        this.checkBuilt();
        assert(this.map.has(metadata), 'Unknown metadata');
        return this.getEntry(this.map.get(metadata));
    }
    build(writer) {
        super.build(writer);
        // No metadata to write
        if (this.strings.size === 0 && this.values.length === 0 &&
            this.tuples.length === 0) {
            return;
        }
        writer.enterBlock(constants_1.BLOCK_ID.METADATA, METADATA_ABBR_ID_WIDTH);
        this.buildStrings(writer);
        this.buildValues(writer);
        this.buildTuples(writer);
        writer.endBlock(constants_1.BLOCK_ID.METADATA);
    }
    // Private methods
    add(metadata) {
        this.checkNotBuilt();
        if (this.map.has(metadata)) {
            return;
        }
        let res;
        if (typeof metadata.value === 'string') {
            res = this.addString(metadata.value);
        }
        else if (Array.isArray(metadata.value)) {
            res = this.addTuple(metadata, metadata.value);
        }
        else {
            res = this.addValue(metadata.value);
        }
        this.map.set(metadata, res);
    }
    addString(value) {
        if (this.strings.has(value)) {
            return { type: 'string', index: this.strings.get(value) };
        }
        const index = this.strings.size;
        this.strings.set(value, index);
        return { type: 'string', index };
    }
    addTuple(metadata, operands) {
        operands.forEach((meta) => this.add(meta));
        const res = {
            distinct: metadata.distinct,
            index: this.tuples.length,
            operands,
            selfReference: metadata.selfReference,
            type: 'tuple',
        };
        this.tuples.push(res);
        return res;
    }
    addValue(value) {
        const res = {
            index: this.values.length,
            type: 'value',
            value,
        };
        this.values.push(res);
        return res;
    }
    getEntry(entry) {
        // Strings come first
        if (entry.type === 'string') {
            return entry.index;
        }
        // Values after strings
        if (entry.type === 'value') {
            return this.strings.size + entry.index;
        }
        // Time for tuples
        assert.strictEqual(entry.type, 'tuple');
        return this.strings.size + this.values.length + entry.index;
    }
    buildStrings(writer) {
        const bufs = [];
        let total = 0;
        const lenWriter = new bitstream_1.BitStream();
        for (const str of this.strings.keys()) {
            const buf = buffer_1.Buffer.from(str);
            bufs.push(buf);
            lenWriter.writeVBR(buf.length, LEN_WRITER_VBR);
            total += buf.length;
        }
        lenWriter.align(DWORD_BITS);
        const lens = lenWriter.end();
        bufs.unshift(lens);
        total += lens.length;
        const blob = buffer_1.Buffer.concat(bufs, total);
        writer.writeRecord('strings', [
            this.strings.size,
            lens.length,
            blob,
        ]);
    }
    buildValues(writer) {
        for (const value of this.values) {
            let ty = value.value.ty;
            // Store pointers to functions
            if (ty.isSignature()) {
                ty = ty.ptr();
            }
            writer.writeRecord('value', [
                this.typeBlock.get(ty),
                this.enumerator.get(value.value),
            ]);
        }
    }
    buildTuples(writer) {
        for (const tuple of this.tuples) {
            let operands = tuple.operands.map((operand) => 1 + this.get(operand));
            if (tuple.selfReference) {
                operands = [1 + this.getEntry(tuple)].concat(operands);
            }
            writer.writeRecord(tuple.distinct ? 'distinct_tuple' : 'tuple', [
                operands,
            ]);
        }
    }
}
exports.MetadataBlock = MetadataBlock;
//# sourceMappingURL=metadata.js.map