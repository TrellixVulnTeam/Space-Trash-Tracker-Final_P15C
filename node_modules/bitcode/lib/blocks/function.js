"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const bitcode_builder_1 = require("bitcode-builder");
const bitstream_1 = require("../bitstream");
const constants_1 = require("../constants");
const encoding_1 = require("../encoding");
const base_1 = require("./base");
const constant_1 = require("./constant");
const metadata_1 = require("./metadata");
const metadata_attachment_1 = require("./metadata-attachment");
var instructions = bitcode_builder_1.values.instructions;
const FUNCTION_ABBR_ID_WIDTH = 6;
const VALUE_SYMTAB_ABBR_ID_WIDTH = 3;
class FunctionBlock extends base_1.Block {
    constructor(enumerator, typeBlock, fn) {
        super();
        this.enumerator = enumerator;
        this.typeBlock = typeBlock;
        this.fn = fn;
    }
    static buildInfo(info) {
        info.set(constants_1.BLOCK_ID.FUNCTION, [
            new bitstream_1.Abbr('declareblocks', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.DECLAREBLOCKS),
                bitstream_1.Abbr.vbr(constants_1.VBR.BLOCK_COUNT),
            ]),
            // Terminators
            new bitstream_1.Abbr('ret_void', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_RET),
            ]),
            new bitstream_1.Abbr('ret', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_RET),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
            ]),
            new bitstream_1.Abbr('jump', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_BR),
                bitstream_1.Abbr.vbr(constants_1.VBR.BLOCK_INDEX),
            ]),
            new bitstream_1.Abbr('branch', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_BR),
                bitstream_1.Abbr.vbr(constants_1.VBR.BLOCK_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.BLOCK_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
            ]),
            new bitstream_1.Abbr('unreachable', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_UNREACHABLE),
            ]),
            // Regular instructions
            new bitstream_1.Abbr('cast', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_CAST),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
                bitstream_1.Abbr.fixed(constants_1.FIXED.CAST_TYPE),
            ]),
            new bitstream_1.Abbr('binop', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_BINOP),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.fixed(constants_1.FIXED.BINOP_TYPE),
            ]),
            new bitstream_1.Abbr('icmp', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_CMP),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.fixed(constants_1.FIXED.PREDICATE),
            ]),
            new bitstream_1.Abbr('load', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_LOAD),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.ALIGNMENT),
                bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
            ]),
            new bitstream_1.Abbr('store', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_STORE),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.ALIGNMENT),
                bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
            ]),
            new bitstream_1.Abbr('getelementptr', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_GEP),
                bitstream_1.Abbr.fixed(constants_1.FIXED.BOOL),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
                bitstream_1.Abbr.array(bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX)),
            ]),
            new bitstream_1.Abbr('extractvalue', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_EXTRACTVAL),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.INTEGER),
            ]),
            new bitstream_1.Abbr('insertvalue', [
                bitstream_1.Abbr.literal(constants_1.FUNCTION_CODE.INST_INSERTVAL),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.vbr(constants_1.VBR.INTEGER),
            ]),
        ]);
        info.set(constants_1.BLOCK_ID.VALUE_SYMTAB, [
            new bitstream_1.Abbr('bbentry', [
                bitstream_1.Abbr.literal(constants_1.VALUE_SYMTAB_CODE.BBENTRY),
                bitstream_1.Abbr.vbr(constants_1.VBR.BLOCK_INDEX),
                bitstream_1.Abbr.array(bitstream_1.Abbr.char6()),
            ]),
            new bitstream_1.Abbr('entry', [
                bitstream_1.Abbr.literal(constants_1.VALUE_SYMTAB_CODE.ENTRY),
                bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX),
                bitstream_1.Abbr.array(bitstream_1.Abbr.char6()),
            ]),
        ]);
    }
    // TODO(indutny): metadata
    build(writer) {
        super.build(writer);
        writer.enterBlock(constants_1.BLOCK_ID.FUNCTION, FUNCTION_ABBR_ID_WIDTH);
        const fn = this.fn;
        const fnConstants = new constant_1.ConstantBlock(this.enumerator, this.typeBlock, this.enumerator.getFunctionConstants(fn));
        fnConstants.build(writer);
        const fnMetadata = new metadata_1.MetadataBlock(this.enumerator, this.typeBlock, this.enumerator.getFunctionMetadata(fn));
        fnMetadata.build(writer);
        const blocks = Array.from(fn);
        const blockIds = new Map();
        blocks.forEach((bb, index) => blockIds.set(bb, index));
        writer.writeRecord('declareblocks', [blocks.length]);
        for (const bb of blocks) {
            for (const instr of bb) {
                this.buildInstruction(writer, instr, blockIds);
            }
        }
        this.buildSymtab(writer, blocks);
        const attachment = new metadata_attachment_1.MetadataAttachmentBlock(fnMetadata, fn, this.enumerator.getMetadataKinds());
        attachment.build(writer);
        writer.endBlock(constants_1.BLOCK_ID.FUNCTION);
        // Reset last emitted id
        this.enumerator.leaveFunction();
    }
    // TODO(indutny): metadata
    buildInstruction(writer, instr, blockIds) {
        this.enumerator.checkValueOrder(instr);
        const instrId = this.enumerator.get(instr);
        const relativeId = (operand) => {
            return instrId - this.enumerator.get(operand);
        };
        // TODO(indutny): support forward references in non-Phi instructions
        // Terminators
        if (instr instanceof instructions.Ret) {
            if (instr.operand === undefined) {
                writer.writeRecord('ret_void', []);
            }
            else {
                writer.writeRecord('ret', [relativeId(instr.operand)]);
            }
        }
        else if (instr instanceof instructions.Jump) {
            assert(blockIds.has(instr.target), 'Unknown block');
            writer.writeRecord('jump', [
                blockIds.get(instr.target),
            ]);
        }
        else if (instr instanceof instructions.Branch) {
            assert(blockIds.has(instr.onTrue), 'Unknown block');
            assert(blockIds.has(instr.onFalse), 'Unknown block');
            writer.writeRecord('branch', [
                blockIds.get(instr.onTrue),
                blockIds.get(instr.onFalse),
                relativeId(instr.condition),
            ]);
        }
        else if (instr instanceof instructions.Switch) {
            assert(blockIds.has(instr.otherwise), 'Unknown block');
            assert(instr.cases.every((c) => blockIds.has(c.block)), 'Unknown block');
            const operands = [
                this.typeBlock.get(instr.condition.ty),
                relativeId(instr.condition),
                blockIds.get(instr.otherwise),
            ];
            for (const c of instr.cases) {
                operands.push(this.enumerator.get(c.value), blockIds.get(c.block));
            }
            writer.writeUnabbrRecord(constants_1.FUNCTION_CODE.INST_SWITCH, operands);
        }
        else if (instr instanceof instructions.Unreachable) {
            writer.writeRecord('unreachable', []);
            // Phi
        }
        else if (instr instanceof instructions.Phi) {
            const operands = [this.typeBlock.get(instr.ty)];
            const edges = instr.edges;
            for (const edge of edges) {
                assert(blockIds.has(edge.fromBlock), `Unknown PHI fromBlock: "${edge.fromBlock}" in ` +
                    `"${edge.fromBlock.parent}"`);
                operands.push(encoding_1.encodeSigned(relativeId(edge.value)));
                operands.push(blockIds.get(edge.fromBlock));
            }
            writer.writeUnabbrRecord(constants_1.FUNCTION_CODE.INST_PHI, operands);
            // Regular instructions
        }
        else if (instr instanceof instructions.Cast) {
            writer.writeRecord('cast', [
                relativeId(instr.operand),
                this.typeBlock.get(instr.targetType),
                encoding_1.encodeCastType(instr.castType),
            ]);
        }
        else if (instr instanceof instructions.Binop) {
            writer.writeRecord('binop', [
                relativeId(instr.left),
                relativeId(instr.right),
                encoding_1.encodeBinopType(instr.binopType),
            ]);
        }
        else if (instr instanceof instructions.ICmp) {
            writer.writeRecord('icmp', [
                relativeId(instr.left),
                relativeId(instr.right),
                encoding_1.encodeICmpPredicate(instr.predicate),
            ]);
        }
        else if (instr instanceof instructions.Load) {
            writer.writeRecord('load', [
                relativeId(instr.ptr),
                this.typeBlock.get(instr.ty),
                instr.alignment === undefined ? 0 : 1 + Math.log2(instr.alignment),
                instr.isVolatile ? 1 : 0,
            ]);
        }
        else if (instr instanceof instructions.Store) {
            writer.writeRecord('store', [
                relativeId(instr.ptr),
                relativeId(instr.value),
                instr.alignment === undefined ? 0 : 1 + Math.log2(instr.alignment),
                instr.isVolatile ? 1 : 0,
            ]);
        }
        else if (instr instanceof instructions.GetElementPtr) {
            const operands = Array.from(instr).map(relativeId);
            writer.writeRecord('getelementptr', [
                instr.inbounds ? 1 : 0,
                this.typeBlock.get(instr.ptr.ty.toPointer().to),
                operands,
            ]);
        }
        else if (instr instanceof instructions.InsertValue) {
            writer.writeRecord('insertvalue', [
                relativeId(instr.aggr),
                relativeId(instr.element),
                instr.index,
            ]);
        }
        else if (instr instanceof instructions.ExtractValue) {
            writer.writeRecord('extractvalue', [
                relativeId(instr.aggr),
                instr.index,
            ]);
        }
        else if (instr instanceof instructions.Call) {
            const operands = [];
            // TODO(indutny): return attributes
            operands.push(0); // attributes
            operands.push(encoding_1.encodeCallFlags(instr));
            // TODO(indutny): optimization flags
            operands.push(this.typeBlock.get(instr.calleeSignature));
            operands.push(relativeId(instr.callee));
            for (const arg of instr.args) {
                operands.push(relativeId(arg));
            }
            writer.writeUnabbrRecord(constants_1.FUNCTION_CODE.INST_CALL, operands);
        }
        else {
            throw new Error(`Unsupported instruction: "${instr.opcode}"`);
        }
    }
    buildSymtab(writer, blocks) {
        // Write block/param names
        writer.enterBlock(constants_1.BLOCK_ID.VALUE_SYMTAB, VALUE_SYMTAB_ABBR_ID_WIDTH);
        blocks.forEach((bb, index) => {
            if (bb.name === undefined) {
                return;
            }
            writer.writeRecord('bbentry', [index, bb.name]);
        });
        this.fn.args.forEach((arg, index) => {
            writer.writeRecord('entry', [this.enumerator.get(arg), arg.name]);
        });
        writer.endBlock(constants_1.BLOCK_ID.VALUE_SYMTAB);
    }
}
exports.FunctionBlock = FunctionBlock;
//# sourceMappingURL=function.js.map