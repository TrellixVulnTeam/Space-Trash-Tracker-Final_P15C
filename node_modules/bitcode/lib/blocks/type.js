"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const bitstream_1 = require("../bitstream");
const constants_1 = require("../constants");
const base_1 = require("./base");
const TYPE_ABBR_ID_WIDTH = 4;
class TypeBlock extends base_1.Block {
    constructor() {
        super(...arguments);
        // typeString => index
        this.indexMap = new Map();
        // typeString => Type in `list`
        this.typeMap = new Map();
    }
    add(ty) {
        this.checkNotBuilt();
        const key = ty.typeString;
        if (this.typeMap.has(key)) {
            const stored = this.typeMap.get(ty.typeString);
            // Sanity check, types must be compatible
            assert(stored.isEqual(ty), `Incompatible types for: "${key}"`);
            return;
        }
        // Add sub-types
        if (ty.isArray()) {
            this.add(ty.toArray().elemType);
        }
        else if (ty.isPointer()) {
            this.add(ty.toPointer().to);
        }
        else if (ty.isSignature()) {
            this.addSignature(ty.toSignature());
        }
        else if (ty.isStruct()) {
            // Break loops created by named structs
            this.typeMap.set(key, ty);
            const struct = ty.toStruct();
            this.addStruct(struct);
            // Ensure correct ordering
            this.typeMap.delete(key);
        }
        this.typeMap.set(key, ty);
    }
    get(ty) {
        this.checkBuilt();
        const key = ty.typeString;
        assert(this.indexMap.has(key), `Type: "${key}" not found`);
        return this.indexMap.get(key);
    }
    build(writer) {
        super.build(writer);
        const list = this.enumerate();
        writer.enterBlock(constants_1.BLOCK_ID.TYPE, TYPE_ABBR_ID_WIDTH);
        writer.writeUnabbrRecord(constants_1.TYPE_CODE.NUMENTRY, [list.length]);
        for (const ty of list) {
            this.write(writer, ty);
        }
        writer.endBlock(constants_1.BLOCK_ID.TYPE);
    }
    // Private API
    addSignature(sig) {
        this.add(sig.returnType);
        for (const param of sig.params) {
            this.add(param);
        }
    }
    addStruct(struct) {
        for (const field of struct.fields) {
            this.add(field.ty);
        }
    }
    enumerate() {
        const list = Array.from(this.typeMap.values());
        list.forEach((ty, index) => this.indexMap.set(ty.typeString, index));
        return list;
    }
    write(writer, ty) {
        // Add sub-types first
        if (ty.isArray()) {
            this.writeArray(writer, ty.toArray());
        }
        else if (ty.isInt()) {
            this.writeInt(writer, ty.toInt());
        }
        else if (ty.isLabel()) {
            this.writeLabel(writer, ty.toLabel());
        }
        else if (ty.isPointer()) {
            this.writePointer(writer, ty.toPointer());
        }
        else if (ty.isSignature()) {
            this.writeSignature(writer, ty.toSignature());
        }
        else if (ty.isStruct()) {
            this.writeStruct(writer, ty.toStruct());
        }
        else if (ty.isVoid()) {
            this.writeVoid(writer, ty.toVoid());
        }
        else {
            throw new Error(`Unsupported type: "${ty.typeString}"`);
        }
    }
    writeArray(writer, ty) {
        if (!writer.hasAbbr('array')) {
            writer.defineAbbr(new bitstream_1.Abbr('array', [
                bitstream_1.Abbr.literal(constants_1.TYPE_CODE.ARRAY),
                bitstream_1.Abbr.vbr(constants_1.VBR.ARRAY_LENGTH),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
            ]));
        }
        writer.writeRecord('array', [ty.length, this.get(ty.elemType)]);
    }
    writeInt(writer, ty) {
        if (!writer.hasAbbr('int')) {
            writer.defineAbbr(new bitstream_1.Abbr('int', [
                bitstream_1.Abbr.literal(constants_1.TYPE_CODE.INTEGER),
                bitstream_1.Abbr.vbr(constants_1.VBR.INT_WIDTH),
            ]));
        }
        writer.writeRecord('int', [ty.width]);
    }
    writeLabel(writer, ty) {
        writer.writeUnabbrRecord(constants_1.TYPE_CODE.LABEL, []);
    }
    writePointer(writer, ty) {
        if (!writer.hasAbbr('ptr')) {
            writer.defineAbbr(new bitstream_1.Abbr('ptr', [
                bitstream_1.Abbr.literal(constants_1.TYPE_CODE.POINTER),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
            ]));
        }
        writer.writeRecord('ptr', [this.get(ty.to)]);
    }
    // TODO(indutny): vararg support
    writeSignature(writer, ty) {
        writer.writeUnabbrRecord(constants_1.TYPE_CODE.FUNCTION, [
            0,
            this.get(ty.returnType),
        ].concat(ty.params.map((p) => this.get(p))));
    }
    // TODO(indutny): support packed structs
    writeStruct(writer, ty) {
        let code = constants_1.TYPE_CODE.STRUCT_ANON;
        if (ty.name !== undefined) {
            if (!writer.hasAbbr('struct_name')) {
                writer.defineAbbr(new bitstream_1.Abbr('struct_name', [
                    bitstream_1.Abbr.literal(constants_1.TYPE_CODE.STRUCT_NAME),
                    bitstream_1.Abbr.array(bitstream_1.Abbr.char6()),
                ]));
            }
            writer.writeRecord('struct_name', [ty.name]);
            code = constants_1.TYPE_CODE.STRUCT_NAMED;
        }
        // TODO(indutny): packed structs support
        const isPacked = 0;
        writer.writeUnabbrRecord(code, [isPacked].concat(ty.fields.map((f) => this.get(f.ty))));
    }
    writeVoid(writer, ty) {
        writer.writeUnabbrRecord(constants_1.TYPE_CODE.VOID, []);
    }
}
exports.TypeBlock = TypeBlock;
//# sourceMappingURL=type.js.map