"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const buffer_1 = require("buffer");
const constants_1 = require("../constants");
const encoding_1 = require("../encoding");
const base_1 = require("./base");
const PARAMATTR_GROUP_ABBR_ID_WIDTH = 2;
const PARAMATTR_ABBR_ID_WIDTH = 2;
// TODO(indutny): use enum?
const WELL_KNOWN = 0;
const WELL_KNOWN_WITH_DATA = 1;
const STRING_ATTR = 3;
const STRING_ATTR_WITH_DATA = 4;
const RET_ATTR_INDEX = 0;
const FN_ATTR_INDEX = 0xffffffff;
class ParamAttrBlock extends base_1.Block {
    constructor() {
        super(...arguments);
        this.groupCache = new Map();
        this.groups = [];
        this.entries = [];
        this.map = new Map();
    }
    addDecl(decl) {
        this.checkNotBuilt();
        const entry = [];
        this.addGroup(RET_ATTR_INDEX, decl.returnAttrs, entry);
        this.addGroup(FN_ATTR_INDEX, decl.attrs, entry);
        decl.paramAttrs.forEach((attrs, index) => {
            return this.addGroup(1 + index, attrs, entry);
        });
        // No parameters to set
        if (entry.length === 0) {
            return;
        }
        this.map.set(decl, this.entries.length);
        this.entries.push(entry);
    }
    addGlobal(global) {
        this.checkNotBuilt();
        const entry = [];
        this.addGroup(FN_ATTR_INDEX, global.attrs, entry);
        // No parameters to set
        if (entry.length === 0) {
            return;
        }
        this.map.set(global, this.entries.length);
        this.entries.push(entry);
    }
    get(value) {
        return this.map.get(value);
    }
    build(writer) {
        super.build(writer);
        if (this.groups.length === 0) {
            return;
        }
        writer.enterBlock(constants_1.BLOCK_ID.PARAMATTR_GROUP, PARAMATTR_GROUP_ABBR_ID_WIDTH);
        for (const group of this.groups) {
            let operands = [group.id, group.paramIndex];
            for (const attr of group.attrs) {
                const key = attr.key;
                const value = attr.value;
                if (typeof key === 'number') {
                    if (value === undefined) {
                        operands.push(WELL_KNOWN, key);
                    }
                    else {
                        assert.strictEqual(typeof value, 'number');
                        operands.push(WELL_KNOWN_WITH_DATA, key, value);
                    }
                }
                else {
                    assert.strictEqual(typeof key, 'string');
                    const arrKey = Array.from(buffer_1.Buffer.from(key));
                    if (value === undefined) {
                        operands.push(STRING_ATTR);
                        operands = operands.concat(arrKey);
                        operands.push(0);
                    }
                    else {
                        assert.strictEqual(typeof value, 'string');
                        operands.push(STRING_ATTR_WITH_DATA);
                        operands = operands.concat(arrKey);
                        operands.push(0);
                        operands = operands.concat(Array.from(buffer_1.Buffer.from(value)));
                        operands.push(0);
                    }
                }
            }
            writer.writeUnabbrRecord(constants_1.PARAMATTR_GROUP_CODE.ENTRY, operands);
        }
        writer.endBlock(constants_1.BLOCK_ID.PARAMATTR_GROUP);
        writer.enterBlock(constants_1.BLOCK_ID.PARAMATTR, PARAMATTR_ABBR_ID_WIDTH);
        for (const entry of this.entries) {
            writer.writeUnabbrRecord(constants_1.PARAMATTR_CODE.ENTRY, entry);
        }
        writer.endBlock(constants_1.BLOCK_ID.PARAMATTR);
    }
    addGroup(paramIndex, attrList, to) {
        const attrs = Array.from(attrList).map((attr) => {
            let key;
            let value;
            if (typeof attr === 'string') {
                key = attr;
            }
            else {
                key = attr.key;
                value = attr.value;
            }
            const knownKey = encoding_1.encodeAttributeKey(key);
            if (knownKey !== undefined) {
                key = knownKey;
                assert(value === undefined || typeof value === 'number', `Invalid known attribute value: "${value}"`);
            }
            return { key, value };
        });
        if (attrs.length === 0) {
            return;
        }
        // Sort by key
        attrs.sort((a, b) => {
            assert.notStrictEqual(a.key, b.key, 'Duplicate attributes');
            return a.key > b.key ? 1 : -1;
        });
        // Compute cache key
        const cacheKeyList = [paramIndex.toString()];
        attrs.forEach((attr) => {
            if (attr.value === undefined) {
                cacheKeyList.push(attr.key.toString());
            }
            else {
                cacheKeyList.push(attr.key.toString() + ':' + attr.value);
            }
        });
        const cacheKey = cacheKeyList.join(',');
        if (this.groupCache.has(cacheKey)) {
            to.push(this.groupCache.get(cacheKey).id);
            return;
        }
        const group = {
            attrs,
            id: this.groups.length + 1,
            paramIndex,
        };
        this.groups.push(group);
        this.groupCache.set(cacheKey, group);
        to.push(group.id);
    }
}
exports.ParamAttrBlock = ParamAttrBlock;
//# sourceMappingURL=param-attr.js.map