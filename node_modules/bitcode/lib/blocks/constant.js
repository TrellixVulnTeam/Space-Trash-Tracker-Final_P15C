"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bitstream_1 = require("../bitstream");
const constants_1 = require("../constants");
const encoding_1 = require("../encoding");
const base_1 = require("./base");
const CONSTANTS_ABBR_ID_WIDTH = 5;
class ConstantBlock extends base_1.Block {
    constructor(enumerator, typeBlock, list) {
        super();
        this.enumerator = enumerator;
        this.typeBlock = typeBlock;
        this.list = list;
    }
    static buildInfo(info) {
        info.set(constants_1.BLOCK_ID.CONSTANTS, [
            new bitstream_1.Abbr('settype', [
                bitstream_1.Abbr.literal(constants_1.CONSTANTS_CODE.SETTYPE),
                bitstream_1.Abbr.vbr(constants_1.VBR.TYPE_INDEX),
            ]),
            new bitstream_1.Abbr('int', [
                bitstream_1.Abbr.literal(constants_1.CONSTANTS_CODE.INTEGER),
                bitstream_1.Abbr.vbr(constants_1.VBR.INTEGER),
            ]),
            new bitstream_1.Abbr('null', [
                bitstream_1.Abbr.literal(constants_1.CONSTANTS_CODE.NULL),
            ]),
            new bitstream_1.Abbr('undef', [
                bitstream_1.Abbr.literal(constants_1.CONSTANTS_CODE.UNDEF),
            ]),
            new bitstream_1.Abbr('aggr', [
                bitstream_1.Abbr.literal(constants_1.CONSTANTS_CODE.AGGREGATE),
                bitstream_1.Abbr.array(bitstream_1.Abbr.vbr(constants_1.VBR.VALUE_INDEX)),
            ]),
        ]);
    }
    build(writer) {
        super.build(writer);
        const list = this.list;
        if (list.length === 0) {
            return;
        }
        writer.enterBlock(constants_1.BLOCK_ID.CONSTANTS, CONSTANTS_ABBR_ID_WIDTH);
        let lastType;
        for (const c of list) {
            if (lastType === undefined || !lastType.isEqual(c.ty)) {
                writer.writeRecord('settype', [this.typeBlock.get(c.ty)]);
                lastType = c.ty;
            }
            this.enumerator.checkValueOrder(c);
            if (c.isInt()) {
                writer.writeRecord('int', [encoding_1.encodeSigned(c.toInt().value)]);
            }
            else if (c.isNull()) {
                writer.writeRecord('null', []);
            }
            else if (c.isUndef()) {
                writer.writeRecord('undef', []);
            }
            else if (c.isArray()) {
                const elems = c.toArray().elems;
                writer.writeRecord('aggr', [elems.map((e) => {
                        return this.enumerator.get(e);
                    })]);
            }
            else if (c.isArray()) {
                const fields = c.toStruct().fields;
                writer.writeRecord('aggr', [fields.map((e) => {
                        return this.enumerator.get(e);
                    })]);
            }
            else if (c.isMetadata()) {
                // TODO(indutny): emit metadata, but not here
                throw new Error('Implement me!');
            }
            else {
                throw new Error(`Unexpected constant value: "${c.constructor.name}"`);
            }
        }
        writer.endBlock(constants_1.BLOCK_ID.CONSTANTS);
    }
}
exports.ConstantBlock = ConstantBlock;
//# sourceMappingURL=constant.js.map