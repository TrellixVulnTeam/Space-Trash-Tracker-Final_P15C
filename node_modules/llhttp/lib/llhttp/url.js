"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
class URL {
    constructor(llparse, mode = 'loose', separateSpans = false) {
        this.llparse = llparse;
        this.mode = mode;
        this.spanTable = new Map();
        const p = this.llparse;
        this.errorInvalid = p.error(constants_1.ERROR.INVALID_URL, 'Invalid characters in url');
        this.errorStrictInvalid =
            p.error(constants_1.ERROR.INVALID_URL, 'Invalid characters in url (strict mode)');
        this.URL_CHAR = mode === 'strict' ? constants_1.STRICT_URL_CHAR : constants_1.URL_CHAR;
        const table = this.spanTable;
        if (separateSpans) {
            table.set('schema', p.span(p.code.span('llhttp__on_url_schema')));
            table.set('host', p.span(p.code.span('llhttp__on_url_host')));
            table.set('path', p.span(p.code.span('llhttp__on_url_path')));
            table.set('query', p.span(p.code.span('llhttp__on_url_query')));
            table.set('fragment', p.span(p.code.span('llhttp__on_url_fragment')));
        }
        else {
            table.set('url', p.span(p.code.span('llhttp__on_url')));
        }
    }
    build() {
        const p = this.llparse;
        const entry = {
            connect: this.node('entry_connect'),
            normal: this.node('entry_normal'),
        };
        const start = this.node('start');
        const path = this.node('path');
        const queryOrFragment = this.node('query_or_fragment');
        const schema = this.node('schema');
        const schemaDelim = this.node('schema_delim');
        const server = this.node('server');
        const queryStart = this.node('query_start');
        const query = this.node('query');
        const fragment = this.node('fragment');
        const serverWithAt = this.node('server_with_at');
        entry.normal
            .otherwise(this.spanStart('url', start));
        entry.connect
            .otherwise(this.spanStart('url', this.spanStart('host', server)));
        start
            .peek(['/', '*'], this.spanStart('path').skipTo(path))
            .peek(constants_1.ALPHA, this.spanStart('schema', schema))
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Unexpected start char in url'));
        schema
            .match(constants_1.ALPHA, schema)
            .peek(':', this.spanEnd('schema').skipTo(schemaDelim))
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Unexpected char in url schema'));
        schemaDelim
            .match('//', this.spanStart('host', server))
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Unexpected char in url schema'));
        [
            server,
            serverWithAt,
        ].forEach((node) => {
            node
                .peek('/', this.spanEnd('host', this.spanStart('path').skipTo(path)))
                .match('?', this.spanEnd('host', this.spanStart('query', query)))
                .match(constants_1.USERINFO_CHARS, server)
                .match(['[', ']'], server)
                .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Unexpected char in url server'));
            if (node !== serverWithAt) {
                node.match('@', serverWithAt);
            }
        });
        serverWithAt
            .match('@', p.error(constants_1.ERROR.INVALID_URL, 'Double @ in url'));
        path
            .match(this.URL_CHAR, path)
            .otherwise(this.spanEnd('path', queryOrFragment));
        // Performance optimization, split `path` so that the fast case remains
        // there
        queryOrFragment
            .match('?', this.spanStart('query', query))
            .match('#', this.spanStart('fragment', fragment))
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Invalid char in url path'));
        query
            .match(this.URL_CHAR, query)
            // Allow extra '?' in query string
            .match('?', query)
            .peek('#', this.spanEnd('query')
            .skipTo(this.spanStart('fragment', fragment)))
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Invalid char in url query'));
        fragment
            .match(this.URL_CHAR, fragment)
            .match(['?', '#'], fragment)
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Invalid char in url fragment start'));
        [start, schema, schemaDelim].forEach((node) => {
            /* No whitespace allowed here */
            node.match([' ', '\r', '\n'], this.errorInvalid);
        });
        // Adaptors
        const toHTTP = this.node('to_http');
        const toHTTP09 = this.node('to_http_09');
        const skipToHTTP = this.node('skip_to_http')
            .skipTo(toHTTP);
        const skipToHTTP09 = this.node('skip_to_http09')
            .skipTo(toHTTP09);
        const skipCRLF = this.node('skip_lf_to_http09')
            .match('\r\n', toHTTP09)
            .otherwise(p.error(constants_1.ERROR.INVALID_URL, 'Expected CRLF'));
        [
            server, serverWithAt, queryOrFragment, queryStart, query,
            fragment,
        ].forEach((node) => {
            let spanName;
            if (node === server || node === serverWithAt) {
                spanName = 'host';
            }
            else if (node === queryStart || node === query) {
                spanName = 'query';
            }
            else if (node === fragment) {
                spanName = 'fragment';
            }
            const endTo = (target) => {
                let res = this.spanEnd('url', target);
                if (spanName !== undefined) {
                    res = this.spanEnd(spanName, res);
                }
                return res;
            };
            node.peek(' ', endTo(skipToHTTP));
            node.peek('\r', endTo(skipCRLF));
            node.peek('\n', endTo(skipToHTTP09));
        });
        return {
            entry,
            exit: {
                toHTTP,
                toHTTP09,
            },
        };
    }
    spanStart(name, otherwise) {
        let res;
        if (this.spanTable.has(name)) {
            res = this.spanTable.get(name).start();
        }
        else {
            res = this.llparse.node('span_start_stub_' + name);
        }
        if (otherwise !== undefined) {
            res.otherwise(otherwise);
        }
        return res;
    }
    spanEnd(name, otherwise) {
        let res;
        if (this.spanTable.has(name)) {
            res = this.spanTable.get(name).end();
        }
        else {
            res = this.llparse.node('span_end_stub_' + name);
        }
        if (otherwise !== undefined) {
            res.otherwise(otherwise);
        }
        return res;
    }
    node(name) {
        const res = this.llparse.node('url_' + name);
        if (this.mode === 'strict') {
            res.match(['\t', '\f'], this.errorStrictInvalid);
        }
        return res;
    }
}
exports.URL = URL;
//# sourceMappingURL=url.js.map