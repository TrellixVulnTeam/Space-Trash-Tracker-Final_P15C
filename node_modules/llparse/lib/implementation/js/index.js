"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSCompiler = void 0;
const constants_1 = require("./constants");
const compilation_1 = require("./compilation");
const code_1 = require("./code");
const node_1 = require("./node");
const transform_1 = require("./transform");
class JSCompiler {
    constructor(container, options) {
        this.options = options;
        container.add(constants_1.CONTAINER_KEY, { code: code_1.default, node: node_1.default, transform: transform_1.default });
    }
    compile(info) {
        const ctx = new compilation_1.Compilation(info.prefix, info.properties, Object.assign({
            module: 'esm',
        }, this.options));
        const out = [];
        // Queue span callbacks to be built before `executeSpans()` code gets called
        // below.
        ctx.reserveSpans(info.spans);
        const root = info.root;
        const rootState = root.get(constants_1.CONTAINER_KEY)
            .build(ctx);
        ctx.buildGlobals(out);
        out.push('');
        out.push('class Parser {');
        out.push('  constructor() {');
        out.push(`    ${ctx.indexField()} = 0;`);
        out.push(`    ${ctx.currentField()} = ${rootState};`);
        out.push(`    ${ctx.statusField()} = 0;`);
        out.push(`    ${ctx.errorField()} = 0;`);
        out.push(`    ${ctx.reasonField()} = null;`);
        out.push(`    ${ctx.errorOffField()} = 0;`);
        // Init custom properties
        for (const { ty, name } of info.properties) {
            let value;
            if (ty === 'i64') {
                value = '0n';
            }
            else if (ty === 'ptr') {
                value = 'null';
            }
            else {
                value = '0';
            }
            out.push(`    ${ctx.stateField(name)} = ${value};`);
        }
        // Init spans
        for (const span of info.spans) {
            out.push(`    ${ctx.spanOffField(span.index)} = -1;`);
            if (span.callbacks.length > 1) {
                out.push(`    ${ctx.spanCbField(span.index)} = null;`);
            }
        }
        out.push('  }');
        out.push('');
        let tmp = [];
        ctx.buildMethods(tmp);
        ctx.indent(out, tmp, '  ');
        // Run
        out.push(`  _run(${ctx.currentArg()}, ${ctx.bufArg()}, ${ctx.offArg()}) {`);
        out.push(`    let ${ctx.matchVar()};`);
        out.push('    for (;;) {');
        out.push(`      switch (${ctx.currentArg()} | 0) {`);
        tmp = [];
        ctx.buildStates(tmp);
        ctx.indent(out, tmp, '        ');
        out.push('      }');
        out.push('    }');
        out.push('    unreachable();');
        out.push('  }');
        out.push('');
        // Execute
        out.push(`  execute(${ctx.bufArg()}) {`);
        out.push('    // check lingering errors');
        out.push(`    if (${ctx.errorField()} !== 0) {`);
        out.push(`      return ${ctx.errorField()};`);
        out.push('    }');
        out.push('');
        tmp = [];
        this.restartSpans(ctx, info, tmp);
        ctx.indent(out, tmp, '    ');
        out.push(`    const next = this._run(` +
            `${ctx.currentField()}, ${ctx.bufArg()}, 0);`);
        out.push(`    if (next === ${constants_1.STATE_ERROR}) {`);
        out.push(`      return ${ctx.errorField()};`);
        out.push('    }');
        out.push(`    ${ctx.currentField()} = next;`);
        out.push('');
        tmp = [];
        this.executeSpans(ctx, info, tmp);
        ctx.indent(out, tmp, '    ');
        out.push('    return 0;');
        out.push('  }');
        out.push('}');
        out.push('');
        out.push('return Parser;');
        return ctx.exportDefault(out);
    }
    restartSpans(ctx, info, out) {
        if (info.spans.length === 0) {
            return;
        }
        out.push('// restart spans');
        for (const span of info.spans) {
            const offField = ctx.spanOffField(span.index);
            out.push(`if (${offField} !== -1) {`);
            out.push(`  ${offField} = 0;`);
            out.push('}');
        }
        out.push('');
    }
    executeSpans(ctx, info, out) {
        if (info.spans.length === 0) {
            return;
        }
        out.push('// execute spans');
        for (const span of info.spans) {
            const offField = ctx.spanOffField(span.index);
            let callback;
            if (span.callbacks.length === 1) {
                callback = ctx.buildCode(ctx.unwrapCode(span.callbacks[0]));
            }
            else {
                callback = ctx.spanCbField(span.index);
            }
            const args = [
                ctx.bufArg(), offField, `${ctx.bufArg()}.length`,
            ];
            out.push(`if (${offField} !== -1) {`);
            out.push(`  const error = ${callback}(${args.join(', ')}) | 0;`);
            // TODO(indutny): de-duplicate this here and in SpanEnd
            out.push('  if (error !== 0) {');
            out.push(`    ${ctx.errorField()} = error;`);
            out.push(`    ${ctx.errorOffField()} = ${ctx.bufArg()}.length;`);
            out.push('    return error;');
            out.push('  }');
            out.push('}');
        }
        out.push('');
    }
}
exports.JSCompiler = JSCompiler;
//# sourceMappingURL=index.js.map