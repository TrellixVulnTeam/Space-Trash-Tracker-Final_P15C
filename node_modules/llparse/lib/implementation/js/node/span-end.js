"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpanEnd = void 0;
const constants_1 = require("../constants");
const base_1 = require("./base");
class SpanEnd extends base_1.Node {
    doBuild(out) {
        const ctx = this.compilation;
        const field = this.ref.field;
        const offField = ctx.spanOffField(field.index);
        // Load start position
        out.push(`const start = ${offField};`);
        // ...and reset
        out.push(`${offField} = -1;`);
        // Invoke callback
        const callback = ctx.buildCode(ctx.unwrapCode(this.ref.callback));
        out.push(`const err = ${callback}(${ctx.bufArg()}, ` +
            `start, ${ctx.offArg()}) | 0;`);
        out.push('if (err !== 0) {');
        const tmp = [];
        this.buildError(tmp, 'err');
        ctx.indent(out, tmp, '  ');
        out.push('}');
        const otherwise = this.ref.otherwise;
        this.tailTo(out, otherwise);
    }
    buildError(out, code) {
        const ctx = this.compilation;
        out.push(`${ctx.errorField()} = ${code};`);
        const otherwise = this.ref.otherwise;
        let resumeOff = ctx.offArg();
        if (!otherwise.noAdvance) {
            resumeOff = `(${resumeOff} + 1)`;
        }
        out.push(`${ctx.errorOffField()} = ${resumeOff};`);
        const resumptionTarget = ctx.unwrapNode(otherwise.node).build(ctx);
        out.push(`${ctx.currentField()} = ${resumptionTarget};`);
        out.push(`return ${constants_1.STATE_ERROR};`);
    }
}
exports.SpanEnd = SpanEnd;
//# sourceMappingURL=span-end.js.map