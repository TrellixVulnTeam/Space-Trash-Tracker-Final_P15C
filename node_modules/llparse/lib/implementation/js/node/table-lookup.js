"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableLookup = void 0;
const assert = require("assert");
const base_1 = require("./base");
const MAX_CHAR = 0xff;
class TableLookup extends base_1.Node {
    doBuild(out) {
        const ctx = this.compilation;
        const table = this.buildTable();
        this.prologue(out);
        const transform = ctx.unwrapTransform(this.ref.transform);
        const current = transform.build(ctx, `${ctx.bufArg()}[${ctx.offArg()}]`);
        out.push(`switch (${table}[${current}]) {`);
        for (const [index, edge] of this.ref.edges.entries()) {
            out.push(`  case ${index + 1}: {`);
            const tmp = [];
            const edge = this.ref.edges[index];
            this.tailTo(tmp, {
                noAdvance: edge.noAdvance,
                node: edge.node,
                value: undefined,
            });
            ctx.indent(out, tmp, '    ');
            out.push('  }');
        }
        out.push(`  default: {`);
        const tmp = [];
        this.tailTo(tmp, this.ref.otherwise);
        ctx.indent(out, tmp, '    ');
        out.push('  }');
        out.push('}');
    }
    // TODO(indutny): reduce copy-paste between `C` and `bitcode` implementations
    buildTable() {
        const table = new Array(MAX_CHAR + 1).fill(0);
        for (const [index, edge] of this.ref.edges.entries()) {
            edge.keys.forEach((key) => {
                assert.strictEqual(table[key], 0);
                table[key] = index + 1;
            });
        }
        return this.compilation.table(table);
    }
}
exports.TableLookup = TableLookup;
//# sourceMappingURL=table-lookup.js.map