"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compilation = void 0;
const assert = require("assert");
const constants_1 = require("./constants");
const match_sequence_1 = require("./helpers/match-sequence");
// Number of hex words per line of blob declaration
const BLOB_GROUP_SIZE = 4;
const TABLE_GROUP_SIZE = 16;
class Compilation {
    constructor(prefix, properties, options) {
        this.prefix = prefix;
        this.properties = properties;
        this.options = options;
        this.stateMap = new Map();
        this.blobs = new Map();
        this.tables = [];
        this.codeMap = new Map();
        this.matchSequence = new Map();
    }
    buildStateEnum(out) {
        let index = 0;
        out.push(`const ${constants_1.STATE_ERROR} = ${index++};`);
        for (const stateName of this.stateMap.keys()) {
            out.push(`const ${stateName} = ${index++};`);
        }
    }
    buildBlobs(out) {
        if (this.blobs.size === 0) {
            return;
        }
        for (const [blob, name] of this.blobs) {
            out.push(`const ${name} = [`);
            for (let i = 0; i < blob.length; i += BLOB_GROUP_SIZE) {
                const limit = Math.min(blob.length, i + BLOB_GROUP_SIZE);
                const hex = [];
                for (let j = i; j < limit; j++) {
                    const value = blob[j];
                    const ch = String.fromCharCode(value);
                    let enc = `0x${value.toString(16)}`;
                    // `'`, `\`
                    if (value === 0x27 || value === 0x5c) {
                        enc = `/* '\\${ch}' */ ` + enc;
                    }
                    else if (value >= 0x20 && value <= 0x7e) {
                        enc = `/* '${ch}' */ ` + enc;
                    }
                    hex.push(enc);
                }
                let line = '  ' + hex.join(', ');
                if (limit !== blob.length) {
                    line += ',';
                }
                out.push(line);
            }
            out.push(`];`);
        }
        out.push('');
    }
    buildTables(out) {
        if (this.tables.length === 0) {
            return;
        }
        for (const { name, value } of this.tables) {
            out.push(`const ${name} = [`);
            for (let i = 0; i < value.length; i += TABLE_GROUP_SIZE) {
                let line = `  ${value.slice(i, i + TABLE_GROUP_SIZE).join(', ')}`;
                if (i + TABLE_GROUP_SIZE < value.length) {
                    line += ',';
                }
                out.push(line);
            }
            out.push('];');
        }
        out.push('');
    }
    buildMatchSequence(out) {
        if (this.matchSequence.size === 0) {
            return;
        }
        for (const match of this.matchSequence.values()) {
            match.build(this, out);
            out.push('');
        }
    }
    reserveSpans(spans) {
        for (const span of spans) {
            for (const callback of span.callbacks) {
                this.buildCode(this.unwrapCode(callback));
            }
        }
    }
    debug(out, message) {
        if (this.options.debug === undefined) {
            return;
        }
        const args = [
            this.stateVar(),
            this.bufArg(),
            this.offArg(),
            JSON.stringify(message),
        ];
        out.push(`${this.options.debug}(${args.join(', ')});`);
    }
    buildGlobals(out) {
        out.push('function unreachable() {');
        out.push('  throw new Error(\'Unreachable\');');
        out.push('}');
        out.push('');
        this.buildBlobs(out);
        this.buildTables(out);
        if (this.matchSequence.size !== 0) {
            match_sequence_1.MatchSequence.buildGlobals(out);
            out.push('');
        }
        this.buildStateEnum(out);
        for (const code of this.codeMap.values()) {
            const tmp = [];
            code.buildGlobal(this, tmp);
            if (tmp.length !== 0) {
                out.push('');
                out.push(...tmp);
            }
        }
    }
    buildMethods(out) {
        this.buildMatchSequence(out);
        for (const code of this.codeMap.values()) {
            code.build(this, out);
            out.push('');
        }
    }
    buildStates(out) {
        this.stateMap.forEach((lines, name) => {
            out.push(`case ${name}: {`);
            lines.forEach((line) => out.push(`  ${line}`));
            out.push('  unreachable();');
            out.push('}');
        });
    }
    addState(state, lines) {
        assert(!this.stateMap.has(state));
        this.stateMap.set(state, lines);
    }
    buildCode(code) {
        if (this.codeMap.has(code.ref.name)) {
            assert.strictEqual(this.codeMap.get(code.ref.name), code, `Code name conflict for "${code.ref.name}"`);
        }
        else {
            this.codeMap.set(code.ref.name, code);
        }
        return `this._${code.ref.name}`;
    }
    getFieldType(field) {
        for (const property of this.properties) {
            if (property.name === field) {
                return property.ty;
            }
        }
        throw new Error(`Field "${field}" not found`);
    }
    exportDefault(lines) {
        const out = [];
        if (this.options.module === 'esm') {
            out.push(`export default (binding) => {`);
        }
        else {
            out.push('\'use strict\';');
            out.push('');
            out.push(`module.exports = (binding) => {`);
        }
        this.indent(out, lines, '  ');
        out.push('};');
        return out.join('\n');
    }
    importCode(name, out) {
        out.push(`const ${name} = binding.${name};`);
    }
    // Helpers
    unwrapCode(code) {
        const container = code;
        return container.get(constants_1.CONTAINER_KEY);
    }
    unwrapNode(node) {
        const container = node;
        return container.get(constants_1.CONTAINER_KEY);
    }
    unwrapTransform(node) {
        const container = node;
        return container.get(constants_1.CONTAINER_KEY);
    }
    indent(out, lines, pad) {
        for (const line of lines) {
            out.push(`${pad}${line}`);
        }
    }
    // MatchSequence cache
    // TODO(indutny): this is practically a copy from `bitcode/compilation.ts`
    // Unify it somehow?
    getMatchSequence(transform, select) {
        const wrap = this.unwrapTransform(transform);
        let res;
        if (this.matchSequence.has(wrap.ref.name)) {
            res = this.matchSequence.get(wrap.ref.name);
        }
        else {
            res = new match_sequence_1.MatchSequence(wrap);
            this.matchSequence.set(wrap.ref.name, res);
        }
        return 'this.' + res.getName();
    }
    // Arguments
    bufArg() {
        return constants_1.ARG_BUF;
    }
    offArg() {
        return constants_1.ARG_OFF;
    }
    currentArg() {
        return constants_1.ARG_CURRENT;
    }
    stateVar() {
        return 'this';
    }
    matchVar() {
        return constants_1.VAR_MATCH;
    }
    // State fields
    indexField() {
        return this.stateField('_index');
    }
    currentField() {
        return this.stateField('_current');
    }
    statusField() {
        return this.stateField('_status');
    }
    errorField() {
        return this.stateField('error');
    }
    reasonField() {
        return this.stateField('reason');
    }
    errorOffField() {
        return this.stateField('errorOff');
    }
    spanOffField(index) {
        return this.stateField(`_spanOff${index}`);
    }
    spanCbField(index) {
        return this.stateField(`_spanCb${index}`);
    }
    stateField(name) {
        return `this.${name}`;
    }
    // Globals
    blob(value) {
        if (this.blobs.has(value)) {
            return this.blobs.get(value);
        }
        const res = constants_1.BLOB_PREFIX + this.blobs.size;
        this.blobs.set(value, res);
        return res;
    }
    table(value) {
        const name = constants_1.TABLE_PREFIX + this.tables.length;
        this.tables.push({ name, value });
        return name;
    }
}
exports.Compilation = Compilation;
//# sourceMappingURL=compilation.js.map