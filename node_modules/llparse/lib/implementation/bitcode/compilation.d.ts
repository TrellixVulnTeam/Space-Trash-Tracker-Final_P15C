/// <reference types="node" />
import { Builder as BitcodeBuilder, builder as bitcodeBuilderNS } from 'bitcode';
import * as frontend from 'llparse-frontend';
import { Code } from './code';
import { Node } from './node';
import { Transform } from './transform';
import irTypes = bitcodeBuilderNS.types;
import irValues = bitcodeBuilderNS.values;
import IRSignature = irTypes.Signature;
import IRDeclaration = irValues.constants.Declaration;
import IRFunc = irValues.constants.Func;
import IRBasicBlock = irValues.BasicBlock;
import IRPhi = irValues.instructions.Phi;
import IRType = irTypes.Type;
import IRValue = irValues.Value;
export { irTypes, irValues, IRBasicBlock, IRDeclaration, IRFunc, IRPhi, IRSignature, IRType, IRValue, };
export interface ICompilationOptions {
    readonly debug?: string;
}
export interface ICompilationProperty {
    readonly name: string;
    readonly ty: string;
}
export interface ISignatureMap {
    readonly callback: {
        readonly match: IRSignature;
        readonly span: IRSignature;
        readonly value: IRSignature;
    };
    readonly node: IRSignature;
}
export declare type IProfWeight = 'likely' | 'unlikely' | number;
export interface IBranchResult {
    readonly onFalse: IRBasicBlock;
    readonly onTrue: IRBasicBlock;
}
export interface IBranchWeight {
    readonly onFalse: IProfWeight;
    readonly onTrue: IProfWeight;
}
export interface ISwitchResult {
    readonly cases: ReadonlyArray<IRBasicBlock>;
    readonly otherwise: IRBasicBlock;
}
export interface ISwitchWeight {
    readonly cases: ReadonlyArray<IProfWeight>;
    readonly otherwise: IProfWeight;
}
export declare class Compilation {
    readonly prefix: string;
    private readonly properties;
    readonly options: ICompilationOptions;
    readonly ir: BitcodeBuilder;
    readonly signature: ISignatureMap;
    readonly state: irTypes.Struct;
    readonly invariantGroup: irValues.constants.Metadata;
    private readonly bitcode;
    private readonly cstringCache;
    private readonly globalId;
    private readonly matchSequence;
    private debugMethod;
    constructor(prefix: string, properties: ReadonlyArray<ICompilationProperty>, spans: ReadonlyArray<frontend.SpanField>, options: ICompilationOptions);
    buildBitcode(init: IRDeclaration): Buffer;
    getMatchSequence(transform: frontend.IWrap<frontend.transform.Transform>, select: Buffer): IRDeclaration;
    buildMatchSequence(): void;
    stateArg(bb: IRBasicBlock): IRValue;
    posArg(bb: IRBasicBlock): IRValue;
    endPosArg(bb: IRBasicBlock): IRValue;
    matchArg(bb: IRBasicBlock): IRValue;
    indexField(bb: IRBasicBlock): IRValue;
    currentField(bb: IRBasicBlock): IRValue;
    errorField(bb: IRBasicBlock): IRValue;
    reasonField(bb: IRBasicBlock): IRValue;
    errorPosField(bb: IRBasicBlock): IRValue;
    spanPosField(bb: IRBasicBlock, index: number): IRValue;
    spanCbField(bb: IRBasicBlock, index: number): IRValue;
    stateField(bb: IRBasicBlock, name: string): IRValue;
    cstring(value: string): IRValue;
    blob(value: Buffer): IRValue;
    addGlobalConst(name: string, init: irValues.constants.Constant): IRValue;
    declareFunction(signature: IRSignature, name: string): IRDeclaration;
    defineFunction(signature: IRSignature, name: string, paramNames: ReadonlyArray<string>): IRFunc;
    branch(bb: IRBasicBlock, condition: IRValue, weights?: IBranchWeight): IBranchResult;
    switch(bb: IRBasicBlock, value: IRValue, keys: ReadonlyArray<number>, weights?: ISwitchWeight): ISwitchResult;
    truncate(bb: IRBasicBlock, value: IRValue, toTy: IRType, isSigned?: boolean): bitcodeBuilderNS.values.Value;
    debug(bb: IRBasicBlock, message: string): IRBasicBlock;
    unwrapCode(code: frontend.IWrap<frontend.code.Code>): Code<frontend.code.Code>;
    unwrapNode(node: frontend.IWrap<frontend.node.Node>): Node<frontend.node.Node>;
    unwrapTransform(node: frontend.IWrap<frontend.transform.Transform>): Transform<frontend.transform.Transform>;
    private toProfWeight;
}
