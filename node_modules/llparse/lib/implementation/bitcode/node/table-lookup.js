"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableLookup = void 0;
const assert = require("assert");
const frontend = require("llparse-frontend");
const constants_1 = require("../constants");
const base_1 = require("./base");
const MAX_CHAR = 0xff;
const CELL_WIDTH = 8;
class TableLookup extends base_1.Node {
    doBuild(bb, pos) {
        bb = this.prologue(bb, pos);
        const table = this.buildTable();
        const ctx = this.compilation;
        // Load the character
        let current = bb.load(pos.current);
        // Transform the character
        current = this.applyTransform(this.ref.transform, bb, current);
        // Extend character to prevent signed problems
        current = ctx.truncate(bb, current, constants_1.GEP_OFF);
        const cell = bb.load(bb.getelementptr(table.global, constants_1.GEP_OFF.val(0), current, true));
        cell.metadata.set('range', ctx.ir.metadata([
            ctx.ir.metadata(cell.ty.toInt().val(0)),
            ctx.ir.metadata(cell.ty.toInt().val(table.nodeToIndex.size + 1)),
        ]));
        const nodes = Array.from(table.nodeToIndex.keys());
        const keys = Array.from(table.nodeToIndex.values());
        // TODO(indutny): de-duplicate this
        // Mark error branches as unlikely
        const cases = nodes.map((node) => {
            if (node.ref instanceof frontend.node.Error) {
                return 'unlikely';
            }
            else {
                return 'likely';
            }
        });
        const s = ctx.switch(bb, cell, keys, {
            cases,
            otherwise: this.ref.otherwise.node.ref instanceof frontend.node.Error ?
                'unlikely' : 'likely',
        });
        this.ref.edges.forEach((edge, index) => {
            this.tailTo(s.cases[index], {
                noAdvance: edge.noAdvance,
                node: edge.node,
                value: undefined,
            }, pos);
        });
        this.tailTo(s.otherwise, this.ref.otherwise, pos);
    }
    // TODO(indutny): reduce copy-paste between `C` and `bitcode` implementations
    buildTable() {
        const table = new Array(MAX_CHAR + 1).fill(0);
        const nodeToIndex = new Map();
        this.ref.edges.forEach((edge) => {
            const index = nodeToIndex.size + 1;
            nodeToIndex.set(edge.node, index);
            edge.keys.forEach((key) => {
                assert.strictEqual(table[key], 0);
                table[key] = index;
            });
        });
        const ctx = this.compilation;
        const cellTy = ctx.ir.i(CELL_WIDTH);
        const array = ctx.ir.array(table.length, cellTy)
            .val(table.map((elem) => cellTy.val(elem)));
        return {
            global: ctx.addGlobalConst('lookup_table', array),
            nodeToIndex,
        };
    }
}
exports.TableLookup = TableLookup;
//# sourceMappingURL=table-lookup.js.map