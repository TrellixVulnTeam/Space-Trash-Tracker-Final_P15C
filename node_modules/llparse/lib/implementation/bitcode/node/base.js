"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
const debugAPI = require("debug");
const constants_1 = require("../constants");
const debug = debugAPI('llparse:bitcode:node');
class Node {
    constructor(ref) {
        this.ref = ref;
        // `noAdvance` => `target` => tail
        this.tailMap = new Map();
        this.tailMap.set(true, new Map());
        this.tailMap.set(false, new Map());
    }
    // Building
    build(ctx) {
        // TODO(indutny): skip `Empty` here too
        if (this.cachedDecl !== undefined) {
            return this.cachedDecl;
        }
        debug('building "%s"', this.ref.id.originalName);
        this.privCompilation = ctx;
        const fn = ctx.defineFunction(ctx.signature.node, this.ref.id.name, [
            constants_1.ARG_STATE, constants_1.ARG_POS, constants_1.ARG_ENDPOS, constants_1.ARG_MATCH,
        ]);
        fn.cconv = constants_1.CCONV;
        fn.linkage = constants_1.LINKAGE;
        fn.paramAttrs[0].add(constants_1.ATTR_STATE);
        fn.paramAttrs[1].add(constants_1.ATTR_POS);
        fn.paramAttrs[2].add(constants_1.ATTR_ENDPOS);
        fn.paramAttrs[3].add(constants_1.ATTR_MATCH);
        fn.attrs.add(constants_1.FN_ATTR_NODE);
        // Cache early to break loops
        this.cachedDecl = fn;
        const pos = {
            current: ctx.posArg(fn.body),
            next: fn.body.getelementptr(ctx.posArg(fn.body), constants_1.GEP_OFF.val(1)),
        };
        const bb = ctx.debug(fn.body, `Entering node "${this.ref.id.originalName}" ("${this.ref.id.name}")`);
        this.doBuild(bb, pos);
        return fn;
    }
    // Helpers
    get compilation() {
        return this.privCompilation;
    }
    applyTransform(transform, bb, value) {
        const wrap = this.compilation.unwrapTransform(transform);
        return wrap.build(this.compilation, bb, value);
    }
    prologue(bb, pos) {
        const ctx = this.compilation;
        // Check that we have enough chars to do the read
        const cmp = bb.icmp('ne', pos.current, ctx.endPosArg(bb));
        const { onTrue, onFalse } = ctx.branch(bb, cmp);
        // Return self when `pos === endpos`
        onFalse.name = 'no_data';
        this.pause(onFalse);
        onTrue.name = 'has_data';
        return onTrue;
    }
    pause(bb) {
        const ctx = this.compilation;
        const fn = bb.parent;
        debug('pause in "%s"', this.ref.id.originalName);
        const self = bb.cast('bitcast', fn, fn.ty.toSignature().returnType);
        bb.ret(self);
    }
    tailTo(bb, edge, pos) {
        const ctx = this.compilation;
        const subTailMap = this.tailMap.get(edge.noAdvance);
        const matchTy = ctx.matchArg(bb).ty;
        // Skip `noAdvance = true` Empty nodes
        const edgeTo = ctx.unwrapNode(edge.node);
        debug('"%s" tails to "%s"', this.ref.id.originalName, edgeTo.ref.id.originalName);
        const value = edge.value === undefined ? matchTy.undef() :
            matchTy.val(edge.value);
        if (subTailMap.has(edgeTo)) {
            const tail = subTailMap.get(edgeTo);
            tail.phi.addEdge({ fromBlock: bb, value });
            bb.jmp(tail.block);
            return;
        }
        const tailBB = bb.parent.createBlock(`${edge.node.ref.id.name}.trampoline`);
        bb.jmp(tailBB);
        const phi = tailBB.phi({ fromBlock: bb, value });
        subTailMap.set(edgeTo, { block: tailBB, phi });
        const args = [
            ctx.stateArg(bb),
            edge.noAdvance ? pos.current : pos.next,
            ctx.endPosArg(bb),
            phi,
        ];
        const res = tailBB.call(edgeTo.build(ctx), args, 'musttail');
        tailBB.ret(res);
    }
}
exports.Node = Node;
//# sourceMappingURL=base.js.map