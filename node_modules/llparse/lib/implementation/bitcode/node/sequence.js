"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sequence = void 0;
const frontend = require("llparse-frontend");
const assert = require("assert");
const constants_1 = require("../constants");
const base_1 = require("./base");
class Sequence extends base_1.Node {
    doBuild(bb, pos) {
        bb = this.prologue(bb, pos);
        const ctx = this.compilation;
        const seq = ctx.blob(this.ref.select);
        const cast = bb.getelementptr(seq, constants_1.GEP_OFF.val(0), constants_1.GEP_OFF.val(0), true);
        assert(this.ref.transform !== undefined);
        const matchSequence = this.compilation.getMatchSequence(this.ref.transform, this.ref.select);
        const returnType = matchSequence.ty.toSignature().returnType.toStruct();
        const call = bb.call(matchSequence, [
            ctx.stateArg(bb),
            pos.current,
            ctx.endPosArg(bb),
            cast,
            constants_1.TYPE_INDEX.val(this.ref.select.length),
        ]);
        const status = bb.extractvalue(call, returnType.lookupField('status').index);
        const current = bb.extractvalue(call, returnType.lookupField('current').index);
        // This is lame, but it is easier to do it this way
        // (Optimizer will remove it, if it isn't needed)
        const next = bb.getelementptr(current, constants_1.GEP_OFF.val(1));
        const s = ctx.switch(bb, status, [
            constants_1.SEQUENCE_PAUSE,
            constants_1.SEQUENCE_MISMATCH,
        ], {
            cases: [
                // SEQUENCE_PAUSE
                'unlikely',
                // SEQUENCE_MISMATCH
                this.ref.otherwise.node.ref instanceof frontend.node.Error ?
                    'unlikely' : 'likely',
            ],
            otherwise: 'likely',
        });
        const complete = s.otherwise;
        const pause = s.cases[0];
        const mismatch = s.cases[1];
        // Matched full sequence
        complete.name = 'complete';
        this.tailTo(complete, {
            noAdvance: false,
            node: this.ref.edge.node,
            value: this.ref.edge.value,
        }, { current, next });
        // Not enough data
        pause.name = 'pause';
        this.pause(pause);
        // Not equal
        mismatch.name = 'mismatch';
        this.tailTo(mismatch, this.ref.otherwise, { current, next });
    }
}
exports.Sequence = Sequence;
//# sourceMappingURL=sequence.js.map