"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpanEnd = void 0;
const base_1 = require("./base");
class SpanEnd extends base_1.Node {
    doBuild(bb, pos) {
        const ctx = this.compilation;
        // Load
        const startPtr = ctx.spanPosField(bb, this.ref.field.index);
        const start = bb.load(startPtr);
        // ...and reset
        bb.store(start.ty.toPointer().val(null), startPtr);
        const callback = ctx.unwrapCode(this.ref.callback);
        const call = bb.call(callback.build(ctx), [
            ctx.stateArg(bb),
            start,
            pos.current,
        ]);
        // Check return value
        const errorCmp = bb.icmp('eq', call, call.ty.toInt().val(0));
        const { onTrue: noError, onFalse: error } = ctx.branch(bb, errorCmp, {
            onFalse: 'unlikely',
            onTrue: 'likely',
        });
        noError.name = 'no_error';
        error.name = 'error';
        // Handle error
        this.buildError(error, pos, call);
        // Otherwise
        this.tailTo(noError, this.ref.otherwise, pos);
    }
    buildError(bb, pos, code) {
        const ctx = this.compilation;
        const errorField = ctx.errorField(bb);
        bb.store(ctx.truncate(bb, code, errorField.ty.toPointer().to), errorField);
        const otherwise = this.ref.otherwise;
        bb.store(otherwise.noAdvance ? pos.current : pos.next, ctx.errorPosField(bb));
        const resumptionTarget = ctx.unwrapNode(otherwise.node).build(ctx);
        bb.store(resumptionTarget, ctx.currentField(bb));
        bb.ret(bb.parent.ty.toSignature().returnType.toPointer().val(null));
    }
}
exports.SpanEnd = SpanEnd;
//# sourceMappingURL=span-end.js.map