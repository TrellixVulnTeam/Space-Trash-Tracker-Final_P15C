"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consume = void 0;
const assert = require("assert");
const constants_1 = require("../constants");
const base_1 = require("./base");
class Consume extends base_1.Node {
    doBuild(bb, pos) {
        const ctx = this.compilation;
        const invariantGroup = ctx.invariantGroup;
        // index = state[field]
        const indexPtr = ctx.stateField(bb, this.ref.field);
        const index = bb.load(indexPtr);
        index.metadata.set('invariant.group', invariantGroup);
        // need = (intptr_t) index
        const need = ctx.truncate(bb, index, constants_1.INTPTR);
        const intPos = bb.cast('ptrtoint', pos.current, constants_1.INTPTR);
        const intEndPos = bb.cast('ptrtoint', ctx.endPosArg(bb), constants_1.INTPTR);
        // avail = endPos - pos
        const avail = bb.binop('sub', intEndPos, intPos);
        // if (avail >= need)
        const cmp = bb.icmp('uge', avail, need);
        const { onTrue: hasData, onFalse: noData } = ctx.branch(bb, cmp, {
            onFalse: 'unlikely',
            onTrue: 'likely',
        });
        hasData.name = 'has_data';
        noData.name = 'no_data';
        // Continue!
        const next = hasData.getelementptr(pos.current, index);
        assert(this.ref.otherwise.noAdvance);
        // state[field] = 0
        hasData.store(index.ty.val(0), indexPtr)
            .metadata.set('invariant.group', invariantGroup);
        this.tailTo(hasData, this.ref.otherwise, { current: next, next });
        // Pause!
        // state[field] = need - avail
        const left = noData.binop('sub', need, avail);
        const leftTrunc = ctx.truncate(noData, left, index.ty);
        noData.store(leftTrunc, indexPtr)
            .metadata.set('invariant.group', invariantGroup);
        this.pause(noData);
    }
}
exports.Consume = Consume;
//# sourceMappingURL=consume.js.map