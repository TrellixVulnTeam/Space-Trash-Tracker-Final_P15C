"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TYPE_DEBUG_MSG = exports.FN_ATTR_ERROR = exports.FN_ATTR_MATCH_SEQUENCE = exports.ATTR_SEQUENCE_LEN = exports.ATTR_SEQUENCE = exports.SEQUENCE_MISMATCH = exports.SEQUENCE_PAUSE = exports.SEQUENCE_COMPLETE = exports.ARG_SEQUENCE_LEN = exports.ARG_SEQUENCE = exports.TYPE_STATUS = exports.TYPE_SEQUENCE_LEN = exports.TYPE_SEQUENCE = exports.STATE_SPAN_CB = exports.STATE_SPAN_POS = exports.STATE_DATA = exports.STATE_ERROR_POS = exports.STATE_REASON = exports.STATE_ERROR = exports.STATE_CURRENT = exports.STATE_INDEX = exports.TYPE_SPAN_POS = exports.TYPE_DATA = exports.TYPE_ERROR_POS = exports.TYPE_REASON = exports.TYPE_ERROR = exports.TYPE_INDEX = exports.FN_ATTR_CODE_EXTERNAL = exports.FN_ATTR_CODE = exports.FN_ATTR_NODE = exports.ATTR_MATCH = exports.ATTR_ENDPOS = exports.ATTR_POS = exports.ATTR_STATE = exports.ARG_MATCH = exports.ARG_ENDPOS = exports.ARG_POS = exports.ARG_STATE = exports.TYPE_MATCH = exports.TYPE_ENDPOS = exports.TYPE_POS = exports.TYPE_OUTPUT = exports.LINKAGE = exports.CCONV = exports.BRANCH_WEIGHT = exports.GEP_OFF = exports.PTR = exports.CSTR = exports.INTPTR = exports.INT = exports.BOOL = exports.I64 = exports.I32 = exports.I16 = exports.I8 = exports.CONTAINER_KEY = void 0;
const bitcode_1 = require("bitcode");
exports.CONTAINER_KEY = 'bitcode';
exports.I8 = bitcode_1.Builder.i(8);
exports.I16 = bitcode_1.Builder.i(16);
exports.I32 = bitcode_1.Builder.i(32);
exports.I64 = bitcode_1.Builder.i(64);
exports.BOOL = bitcode_1.Builder.i(1);
exports.INT = exports.I32;
exports.INTPTR = exports.I64; // TODO(indutny): find a way to do it cross-platform
exports.CSTR = bitcode_1.Builder.i(8).ptr();
exports.PTR = bitcode_1.Builder.i(8).ptr();
exports.GEP_OFF = exports.INT;
exports.BRANCH_WEIGHT = exports.INT;
exports.CCONV = 'fastcc';
exports.LINKAGE = 'internal';
// Arguments
exports.TYPE_OUTPUT = exports.PTR;
exports.TYPE_POS = exports.CSTR;
exports.TYPE_ENDPOS = exports.TYPE_POS;
exports.TYPE_MATCH = exports.INT;
exports.ARG_STATE = 'state';
exports.ARG_POS = 'pos';
exports.ARG_ENDPOS = 'endpos';
exports.ARG_MATCH = 'match';
exports.ATTR_STATE = ['noalias', 'nonnull'];
exports.ATTR_POS = ['noalias', 'nonnull', 'readonly'];
exports.ATTR_ENDPOS = ['noalias', 'nonnull', 'readnone'];
exports.ATTR_MATCH = [];
exports.FN_ATTR_NODE = [
    // TODO(indutny): reassess `minsize`. Looks like it gives best performance
    // results right now, though.
    'nounwind', 'minsize', 'ssp', 'uwtable',
];
exports.FN_ATTR_CODE = [
    'nounwind', 'norecurse', 'ssp', 'uwtable',
];
exports.FN_ATTR_CODE_EXTERNAL = ['alwaysinline'];
// State
exports.TYPE_INDEX = exports.INT;
exports.TYPE_ERROR = exports.INT;
exports.TYPE_REASON = exports.CSTR;
exports.TYPE_ERROR_POS = exports.TYPE_POS;
exports.TYPE_DATA = exports.PTR;
exports.TYPE_SPAN_POS = exports.TYPE_POS;
exports.STATE_INDEX = '_index';
exports.STATE_CURRENT = '_current';
exports.STATE_ERROR = 'error';
exports.STATE_REASON = 'reason';
exports.STATE_ERROR_POS = 'error_pos';
exports.STATE_DATA = 'data';
exports.STATE_SPAN_POS = '_span_pos';
exports.STATE_SPAN_CB = '_span_cb';
// Sequence Matcher
exports.TYPE_SEQUENCE = exports.TYPE_POS;
exports.TYPE_SEQUENCE_LEN = exports.TYPE_INDEX;
exports.TYPE_STATUS = exports.INT;
exports.ARG_SEQUENCE = 'seq';
exports.ARG_SEQUENCE_LEN = 'seq_len';
exports.SEQUENCE_COMPLETE = 0;
exports.SEQUENCE_PAUSE = 1;
exports.SEQUENCE_MISMATCH = 2;
exports.ATTR_SEQUENCE = exports.ATTR_POS;
exports.ATTR_SEQUENCE_LEN = [];
exports.FN_ATTR_MATCH_SEQUENCE = [
    'nounwind', 'norecurse', 'alwaysinline',
];
// Nodes in general
exports.FN_ATTR_ERROR = [
    'norecurse', 'cold', 'writeonly', 'noinline',
];
// Debug
exports.TYPE_DEBUG_MSG = exports.CSTR;
//# sourceMappingURL=constants.js.map