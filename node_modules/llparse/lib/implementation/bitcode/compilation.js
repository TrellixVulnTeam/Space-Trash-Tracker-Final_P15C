"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compilation = exports.IRValue = exports.IRType = exports.IRSignature = exports.IRPhi = exports.IRFunc = exports.IRDeclaration = exports.IRBasicBlock = exports.irValues = exports.irTypes = void 0;
const assert = require("assert");
const bitcode_1 = require("bitcode");
const frontend = require("llparse-frontend");
const constants = require("./constants");
const match_sequence_1 = require("./helpers/match-sequence");
var irTypes = bitcode_1.builder.types;
exports.irTypes = irTypes;
var irValues = bitcode_1.builder.values;
exports.irValues = irValues;
var IRSignature = irTypes.Signature;
exports.IRSignature = IRSignature;
var IRDeclaration = irValues.constants.Declaration;
exports.IRDeclaration = IRDeclaration;
var IRFunc = irValues.constants.Func;
exports.IRFunc = IRFunc;
var IRBasicBlock = irValues.BasicBlock;
exports.IRBasicBlock = IRBasicBlock;
var IRPhi = irValues.instructions.Phi;
exports.IRPhi = IRPhi;
var IRType = irTypes.Type;
exports.IRType = IRType;
var IRValue = irValues.Value;
exports.IRValue = IRValue;
class Compilation {
    constructor(prefix, properties, spans, options) {
        this.prefix = prefix;
        this.properties = properties;
        this.options = options;
        this.bitcode = new bitcode_1.Module();
        this.cstringCache = new Map();
        this.globalId = new frontend.Identifier('g_');
        this.matchSequence = new Map();
        this.debugMethod = undefined;
        this.ir = this.bitcode.createBuilder();
        this.invariantGroup = this.ir.metadata([
            this.ir.metadata('llparse.invariant'),
        ]);
        this.state = this.ir.struct('state');
        this.signature = {
            callback: {
                match: this.ir.signature(constants.INT, [
                    this.state.ptr(),
                    constants.TYPE_POS,
                    constants.TYPE_ENDPOS,
                ]),
                span: this.ir.signature(constants.INT, [
                    this.state.ptr(),
                    constants.TYPE_POS,
                    constants.TYPE_ENDPOS,
                ]),
                value: this.ir.signature(constants.INT, [
                    this.state.ptr(),
                    constants.TYPE_POS,
                    constants.TYPE_ENDPOS,
                    constants.TYPE_MATCH,
                ]),
            },
            node: this.ir.signature(constants.TYPE_OUTPUT, [
                this.state.ptr(),
                constants.TYPE_POS,
                constants.TYPE_ENDPOS,
                constants.TYPE_MATCH,
            ]),
        };
        // Put most used fields first
        this.state.addField(constants.TYPE_INDEX, constants.STATE_INDEX);
        spans.forEach((span) => {
            this.state.addField(constants.TYPE_SPAN_POS, constants.STATE_SPAN_POS + span.index);
            if (span.callbacks.length > 1) {
                this.state.addField(this.signature.callback.span.ptr(), constants.STATE_SPAN_CB + span.index);
            }
        });
        this.state.addField(constants.TYPE_ERROR, constants.STATE_ERROR);
        this.state.addField(constants.TYPE_REASON, constants.STATE_REASON);
        this.state.addField(constants.TYPE_ERROR_POS, constants.STATE_ERROR_POS);
        this.state.addField(constants.TYPE_DATA, constants.STATE_DATA);
        this.state.addField(this.signature.node.ptr(), constants.STATE_CURRENT);
        for (const property of properties) {
            let ty;
            switch (property.ty) {
                case 'i8':
                    ty = constants.I8;
                    break;
                case 'i16':
                    ty = constants.I16;
                    break;
                case 'i32':
                    ty = constants.I32;
                    break;
                case 'i64':
                    ty = constants.I64;
                    break;
                case 'ptr':
                    ty = constants.PTR;
                    break;
                default: throw new Error(`Unsupported user type: "${property.ty}"`);
            }
            this.state.addField(ty, property.name);
        }
        this.state.finalize();
    }
    buildBitcode(init) {
        return this.bitcode.build();
    }
    // MatchSequence cache
    getMatchSequence(transform, select) {
        const wrap = this.unwrapTransform(transform);
        let match;
        if (this.matchSequence.has(wrap.ref.name)) {
            match = this.matchSequence.get(wrap.ref.name);
        }
        else {
            match = new match_sequence_1.MatchSequence(wrap);
            this.matchSequence.set(wrap.ref.name, match);
        }
        match.addSequence(select);
        return match.preBuild(this);
    }
    buildMatchSequence() {
        for (const match of this.matchSequence.values()) {
            match.build(this);
        }
    }
    // Arguments
    stateArg(bb) {
        return bb.parent.getArgument(constants.ARG_STATE);
    }
    posArg(bb) {
        return bb.parent.getArgument(constants.ARG_POS);
    }
    endPosArg(bb) {
        return bb.parent.getArgument(constants.ARG_ENDPOS);
    }
    matchArg(bb) {
        return bb.parent.getArgument(constants.ARG_MATCH);
    }
    // State fields
    indexField(bb) {
        return this.stateField(bb, constants.STATE_INDEX);
    }
    currentField(bb) {
        return this.stateField(bb, constants.STATE_CURRENT);
    }
    errorField(bb) {
        return this.stateField(bb, constants.STATE_ERROR);
    }
    reasonField(bb) {
        return this.stateField(bb, constants.STATE_REASON);
    }
    errorPosField(bb) {
        return this.stateField(bb, constants.STATE_ERROR_POS);
    }
    spanPosField(bb, index) {
        return this.stateField(bb, constants.STATE_SPAN_POS + index);
    }
    spanCbField(bb, index) {
        return this.stateField(bb, constants.STATE_SPAN_CB + index);
    }
    stateField(bb, name) {
        const state = this.stateArg(bb);
        const GEP_OFF = constants.GEP_OFF;
        const index = this.state.lookupField(name).index;
        return bb.getelementptr(state, GEP_OFF.val(0), GEP_OFF.val(index), true);
    }
    // Globals
    cstring(value) {
        if (this.cstringCache.has(value)) {
            return this.cstringCache.get(value);
        }
        const res = this.addGlobalConst('cstr', this.ir.cstring(value));
        this.cstringCache.set(value, res);
        return res;
    }
    blob(value) {
        return this.addGlobalConst('blob', this.ir.blob(value));
    }
    addGlobalConst(name, init) {
        const uniqueName = this.globalId.id(name).name;
        const glob = this.ir.global(init.ty.ptr(), uniqueName, init);
        glob.linkage = 'internal';
        glob.markConstant();
        this.bitcode.add(glob);
        return glob;
    }
    declareFunction(signature, name) {
        const decl = signature.declareFunction(name);
        this.bitcode.add(decl);
        return decl;
    }
    defineFunction(signature, name, paramNames) {
        const fn = signature.defineFunction(name, paramNames);
        this.bitcode.add(fn);
        return fn;
    }
    // Miscellaneous
    branch(bb, condition, weights) {
        const onTrue = bb.parent.createBlock('on_true');
        const onFalse = bb.parent.createBlock('on_false');
        const br = bb.branch(condition, onTrue, onFalse);
        if (weights !== undefined) {
            const WEIGHT = constants.BRANCH_WEIGHT;
            br.metadata.set('prof', this.ir.metadata([
                this.ir.metadata('branch_weights'),
                this.ir.metadata(WEIGHT.val(this.toProfWeight(weights.onTrue))),
                this.ir.metadata(WEIGHT.val(this.toProfWeight(weights.onFalse))),
            ]));
        }
        return { onTrue, onFalse };
    }
    switch(bb, value, keys, weights) {
        const otherwise = bb.parent.createBlock('otherwise');
        const cases = keys.map((key) => {
            return {
                block: bb.parent.createBlock(`case_${key}`),
                value: value.ty.toInt().val(key),
            };
        });
        const br = bb.switch(value, otherwise, cases);
        if (weights !== undefined) {
            const WEIGHT = constants.BRANCH_WEIGHT;
            assert.strictEqual(weights.cases.length, keys.length);
            const list = [
                this.ir.metadata('branch_weights'),
                this.ir.metadata(WEIGHT.val(this.toProfWeight(weights.otherwise))),
            ];
            for (const weight of weights.cases) {
                list.push(this.ir.metadata(WEIGHT.val(this.toProfWeight(weight))));
            }
            br.metadata.set('prof', this.ir.metadata(list));
        }
        return { otherwise, cases: cases.map((c) => c.block) };
    }
    truncate(bb, value, toTy, isSigned = false) {
        const fromTy = value.ty;
        assert(toTy.isInt());
        assert(fromTy.isInt());
        const fromITy = fromTy.toInt();
        const toITy = toTy.toInt();
        let res;
        // Same type!
        if (fromITy.isEqual(toITy)) {
            res = value;
            // Extend
        }
        else if (fromITy.width < toITy.width) {
            if (isSigned) {
                res = bb.cast('sext', value, toITy);
            }
            else {
                res = bb.cast('zext', value, toITy);
            }
            // Truncate
        }
        else {
            assert(fromITy.width > toITy.width);
            res = bb.cast('trunc', value, toITy);
        }
        return res;
    }
    debug(bb, message) {
        if (this.options.debug === undefined) {
            return bb;
        }
        // Lazily declare debug method
        if (this.debugMethod === undefined) {
            const sig = this.ir.signature(this.ir.void(), [
                this.state.ptr(),
                constants.TYPE_POS,
                constants.TYPE_ENDPOS,
                constants.TYPE_DEBUG_MSG,
            ]);
            this.debugMethod = this.declareFunction(sig, this.options.debug);
        }
        const str = this.cstring(message);
        const GEP_OFF = constants.GEP_OFF;
        const cast = bb.getelementptr(str, GEP_OFF.val(0), GEP_OFF.val(0), true);
        bb.call(this.debugMethod, [
            this.stateArg(bb),
            this.posArg(bb),
            this.endPosArg(bb),
            cast,
        ]);
        return bb;
    }
    unwrapCode(code) {
        const container = code;
        return container.get(constants.CONTAINER_KEY);
    }
    unwrapNode(node) {
        const container = node;
        return container.get(constants.CONTAINER_KEY);
    }
    unwrapTransform(node) {
        const container = node;
        return container.get(constants.CONTAINER_KEY);
    }
    // Internals
    toProfWeight(weight) {
        // Completely ad-hoc
        if (weight === 'likely') {
            return 0x10000;
        }
        else if (weight === 'unlikely') {
            return 1;
        }
        else {
            return weight;
        }
    }
}
exports.Compilation = Compilation;
//# sourceMappingURL=compilation.js.map