"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteBuilder = void 0;
const constants_1 = require("../constants");
class ExecuteBuilder {
    build(ctx, info) {
        const sig = ctx.ir.signature(constants_1.TYPE_ERROR, [
            ctx.state.ptr(), constants_1.TYPE_POS, constants_1.TYPE_ENDPOS
        ]);
        const fn = ctx.defineFunction(sig, `${ctx.prefix}_execute`, [constants_1.ARG_STATE, constants_1.ARG_POS, constants_1.ARG_ENDPOS]);
        fn.paramAttrs[0].add(constants_1.ATTR_STATE);
        fn.paramAttrs[1].add(constants_1.ATTR_POS);
        fn.paramAttrs[2].add(constants_1.ATTR_ENDPOS);
        fn.linkage = 'external';
        const noLinger = this.checkLingeringError(ctx, fn.body);
        const bb = this.restartSpans(ctx, info.spans, noLinger);
        const current = bb.load(ctx.currentField(bb));
        const call = bb.call(current, [
            ctx.stateArg(bb),
            ctx.posArg(bb),
            ctx.endPosArg(bb),
            current.ty.toPointer().to.toSignature().params[3].undef(),
        ], 'normal', constants_1.CCONV);
        const callees = Array.from(info.resumptionTargets).map((target) => {
            return ctx.ir.metadata(ctx.unwrapNode(target).build(ctx));
        });
        call.metadata.set('callees', ctx.ir.metadata(callees));
        const cmp = bb.icmp('ne', call, call.ty.toPointer().val(null));
        const { onTrue: success, onFalse: error } = ctx.branch(bb, cmp, {
            onFalse: 'unlikely',
            onTrue: 'likely',
        });
        success.name = 'success';
        const bitcast = success.cast('bitcast', call, current.ty);
        success.store(bitcast, ctx.currentField(success));
        this.executeSpans(ctx, info.spans, success).ret(constants_1.TYPE_ERROR.val(0));
        error.name = 'error';
        error.ret(error.load(ctx.errorField(error)));
    }
    checkLingeringError(ctx, bb) {
        const code = bb.load(ctx.errorField(bb));
        const cmp = bb.icmp('eq', code, code.ty.toInt().val(0));
        const { onTrue: noError, onFalse: error } = ctx.branch(bb, cmp, {
            onFalse: 'unlikely',
            onTrue: 'likely',
        });
        error.name = 'error';
        error.ret(code);
        noError.name = 'no_error';
        return noError;
    }
    restartSpans(ctx, spans, bb) {
        spans.forEach((span) => {
            const startPtr = ctx.spanPosField(bb, span.index);
            const start = bb.load(startPtr);
            const cmp = bb.icmp('eq', start, start.ty.toPointer().val(null));
            const { onTrue: empty, onFalse: restart } = ctx.branch(bb, cmp);
            empty.name = 'span_empty_' + span.index;
            restart.name = 'span_restart_' + span.index;
            restart.store(ctx.posArg(bb), startPtr);
            // Join
            restart.jmp(empty);
            bb = empty;
        });
        return bb;
    }
    executeSpans(ctx, spans, bb) {
        spans.forEach((span) => {
            const start = bb.load(ctx.spanPosField(bb, span.index));
            const cmp = bb.icmp('ne', start, start.ty.toPointer().val(null));
            const { onTrue: present, onFalse: empty } = ctx.branch(bb, cmp);
            present.name = 'span_present_' + span.index;
            empty.name = 'span_empty_' + span.index;
            let cb;
            if (span.callbacks.length === 1) {
                cb = ctx.unwrapCode(span.callbacks[0]).build(ctx);
            }
            else {
                cb = present.load(ctx.spanCbField(present, span.index));
            }
            // TODO(indutny): this won't work with internal callbacks due to
            // cconv mismatch in indirect call
            const call = present.call(cb, [
                ctx.stateArg(present),
                start,
                ctx.endPosArg(present),
            ]);
            if (span.callbacks.length > 1) {
                const callees = span.callbacks.map((callback) => {
                    return ctx.ir.metadata(ctx.unwrapCode(callback).build(ctx));
                });
                call.metadata.set('callees', ctx.ir.metadata(callees));
            }
            // Check return value
            const errorCmp = present.icmp('eq', call, call.ty.toInt().val(0));
            const { onTrue: noError, onFalse: error } = ctx.branch(present, errorCmp, { onTrue: 'likely', onFalse: 'unlikely' });
            noError.name = 'span_no_error_' + span.index;
            error.name = 'span_error_' + span.index;
            this.buildError(ctx, error, call);
            error.ret(call);
            noError.jmp(empty);
            bb = empty;
        });
        return bb;
    }
    // TODO(indutny): de-duplicate this here and in SpanEnd
    buildError(ctx, bb, code) {
        bb.store(code, ctx.errorField(bb));
        bb.store(ctx.endPosArg(bb), ctx.errorPosField(bb));
    }
}
exports.ExecuteBuilder = ExecuteBuilder;
//# sourceMappingURL=execute-builder.js.map