"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchSequence = void 0;
const assert = require("assert");
const constants_1 = require("../constants");
class MatchSequence {
    constructor(transform) {
        this.transform = transform;
        this.maxSequenceLen = 0;
    }
    addSequence(sequence) {
        this.maxSequenceLen = Math.max(this.maxSequenceLen, sequence.length);
    }
    preBuild(ctx) {
        if (this.cachedFn !== undefined) {
            return this.cachedFn;
        }
        const returnType = ctx.ir.struct();
        returnType.addField(constants_1.TYPE_POS, 'current');
        returnType.addField(constants_1.TYPE_STATUS, 'status');
        returnType.finalize();
        const signature = ctx.ir.signature(returnType, [
            ctx.state.ptr(),
            constants_1.TYPE_POS,
            constants_1.TYPE_ENDPOS,
            constants_1.TYPE_SEQUENCE,
            constants_1.TYPE_SEQUENCE_LEN,
        ]);
        const fn = ctx.defineFunction(signature, `${ctx.prefix}__match_sequence_${this.transform.ref.name}`, [constants_1.ARG_STATE, constants_1.ARG_POS, constants_1.ARG_ENDPOS, constants_1.ARG_SEQUENCE, constants_1.ARG_SEQUENCE_LEN]);
        fn.paramAttrs[0].add(constants_1.ATTR_STATE);
        fn.paramAttrs[1].add(constants_1.ATTR_POS);
        fn.paramAttrs[2].add(constants_1.ATTR_ENDPOS);
        fn.paramAttrs[3].add(constants_1.ATTR_SEQUENCE);
        fn.paramAttrs[4].add(constants_1.ATTR_SEQUENCE_LEN);
        fn.attrs.add(constants_1.FN_ATTR_MATCH_SEQUENCE);
        fn.linkage = constants_1.LINKAGE;
        fn.cconv = constants_1.CCONV;
        this.cachedFn = fn;
        return fn;
    }
    build(ctx) {
        assert(this.cachedFn !== undefined);
        this.buildBody(ctx, this.cachedFn.body);
    }
    buildBody(ctx, bb) {
        // Just to have a label
        const start = bb.parent.createBlock('start');
        bb.jmp(start);
        // Load `state.index`
        const index = start.load(ctx.indexField(start));
        index.metadata.set('invariant.group', ctx.invariantGroup);
        index.metadata.set('range', ctx.ir.metadata([
            ctx.ir.metadata(index.ty.toInt().val(0)),
            ctx.ir.metadata(index.ty.toInt().val(this.maxSequenceLen)),
        ]));
        // Loop start
        const loop = bb.parent.createBlock('loop');
        start.jmp(loop);
        const posPhi = loop.phi({ fromBlock: start, value: ctx.posArg(bb) });
        const indexPhi = loop.phi({ fromBlock: start, value: index });
        const iteration = this.buildIteration(ctx, loop, posPhi, indexPhi);
        // It is complete!
        this.ret(iteration.complete, iteration.pos.current, constants_1.SEQUENCE_COMPLETE);
        // We have more data!
        iteration.loop.jmp(loop).metadata.set('llvm.loop', ctx.ir.metadata([]).addSelfReference().markDistinct());
        indexPhi.addEdge({ fromBlock: iteration.loop, value: iteration.index });
        posPhi.addEdge({ fromBlock: iteration.loop, value: iteration.pos.next });
        // Have to pause - return self
        this.ret(iteration.pause, iteration.pos.current, constants_1.SEQUENCE_PAUSE);
        // Not equal
        this.ret(iteration.mismatch, iteration.pos.current, constants_1.SEQUENCE_MISMATCH);
    }
    buildIteration(ctx, bb, pos, index) {
        const seq = bb.parent.getArgument(constants_1.ARG_SEQUENCE);
        const seqLen = bb.parent.getArgument(constants_1.ARG_SEQUENCE_LEN);
        let current = bb.load(pos);
        // Transform the character
        current = this.transform.build(ctx, bb, current);
        const expected = bb.load(bb.getelementptr(seq, index));
        // NOTE: fetch this early so it would dominate all returns
        const next = bb.getelementptr(pos, constants_1.GEP_OFF.val(1));
        let cmp = bb.icmp('eq', current, expected);
        const { onTrue: isMatch, onFalse: isMismatch } = ctx.branch(bb, cmp);
        isMatch.name = 'match';
        isMismatch.name = 'mismatch';
        // Mismatch
        this.reset(ctx, isMismatch);
        // Character matches
        const index1 = isMatch.binop('add', index, index.ty.val(1));
        cmp = isMatch.icmp('eq', index1, seqLen);
        const { onTrue: isComplete, onFalse: isIncomplete } = ctx.branch(isMatch, cmp);
        isComplete.name = 'is_complete';
        isIncomplete.name = 'is_incomplete';
        this.reset(ctx, isComplete);
        cmp = isIncomplete.icmp('ne', next, ctx.endPosArg(bb));
        const { onTrue: moreData, onFalse: noMoreData } = ctx.branch(isIncomplete, cmp, { onTrue: 'likely', onFalse: 'unlikely' });
        moreData.name = 'more_data';
        noMoreData.name = 'no_more_data';
        const store = noMoreData.store(index1, ctx.indexField(noMoreData));
        store.metadata.set('invariant.group', ctx.invariantGroup);
        return {
            complete: isComplete,
            index: index1,
            loop: moreData,
            mismatch: isMismatch,
            pause: noMoreData,
            pos: { current: pos, next },
        };
    }
    ret(bb, pos, status) {
        const returnType = bb.parent.ty.toSignature().returnType.toStruct();
        const create = bb.insertvalue(returnType.undef(), pos, returnType.lookupField('current').index);
        const statusField = returnType.lookupField('status');
        const amend = bb.insertvalue(create, statusField.ty.val(status), statusField.index);
        bb.ret(amend);
    }
    reset(ctx, bb) {
        const ptr = ctx.indexField(bb);
        const store = bb.store(ptr.ty.toPointer().to.val(0), ptr);
        store.metadata.set('invariant.group', ctx.invariantGroup);
    }
}
exports.MatchSequence = MatchSequence;
//# sourceMappingURL=match-sequence.js.map